<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangliangnbu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Developer For Android">
<meta property="og:type" content="website">
<meta property="og:title" content="永恒的码流">
<meta property="og:url" content="https://zhangliangnbu.github.io/index.html">
<meta property="og:site_name" content="永恒的码流">
<meta property="og:description" content="Developer For Android">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="章亮">
<meta property="article:tag" content="Andriod">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zhangliangnbu.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>永恒的码流</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">永恒的码流</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">万物皆流，无物常驻</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangliangnbu.github.io/2022/01/06/android-launcher-customized-layout-summarize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="章亮">
      <meta itemprop="description" content="Developer For Android">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒的码流">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/06/android-launcher-customized-layout-summarize/" class="post-title-link" itemprop="url">拖拽和动画实践总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-06 15:10:09" itemprop="dateCreated datePublished" datetime="2022-01-06T15:10:09+08:00">2022-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-07 15:02:25" itemprop="dateModified" datetime="2022-01-07T15:02:25+08:00">2022-01-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Android系统开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前参与了Launcher项目，负责样式的自定义布局部分。这部分主要涉及到的技术点是自定义布局和动画，难度适中，但略繁杂，其中有几个技术相关的难点记录如下。</p>
<h1 id="手指长按触发拖动"><a href="#手指长按触发拖动" class="headerlink" title="手指长按触发拖动"></a>手指长按触发拖动</h1><p>下图边框表示一个ViewGroup，包含8个子View。我们希望长按某个子View，并拖动它到其他的位置，比如长按View-1后，显示能够拖动，然后拖动它到View-7的位置。</p>
<p><img src="/images/android-launcher-customized-1.drawio.svg" alt="android-launcher-customized-1.drawio"></p>
<p>Github上应该有相关框架，可以自己实现但不需要，因为Android提供了相关API，见<a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/ui/drag-drop">官方文档</a>。其原理是创建待拖动View的副本，并跟随手指触摸坐标更改副本View的位置。使用流程为在View的长按监听回调<code>OnLongClickListener.onLongClick(View v)</code>里调用开启拖动的方法<code>View.startDragAndDrop()</code>，然后在父视图中注册拖动回调监听即可触发拖动事件的回调方法<code>OnDragListener.onDragEvent()</code>，之后根据坐标判断拖动结束的地方或View。</p>
<h1 id="拖动View到页面边界触延时连续页面切换"><a href="#拖动View到页面边界触延时连续页面切换" class="headerlink" title="拖动View到页面边界触延时连续页面切换"></a>拖动View到页面边界触延时连续页面切换</h1><p>在一个ViewPager里，我们希望拖动当前Pager里的一个View到Pager的边界时，会自动切换Pager。但切换之后我们不希望马上连续切换，因为我们希望在切换后的Pager里，留给用户些许时间来判断是否释放掉拖动的View。比如下图中，我们拖动View-2到Pager的左边界时，我们希望它切换到第2个页面，并且留些许时间让用户考虑是否将View-2放在页面2，如果不放在页面2，用户会继续保持长按，则会继续切换到页面1。</p>
<p><img src="/images/android-launcher-customized-2.svg" alt="android-launcher-customized-2"></p>
<p>实现：监听<code>DragEvent.ACTION_DRAG_LOCATION</code>事件，获取实时坐标，判断是否需要切换Pager，如果切换则发送一个延时消息，在这个延时消息触发之前不允许再次切换Pager。</p>
<p>关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听DragEvent.ACTION_DRAG_LOCATION事件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDrag</span><span class="params">(View v, DragEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">    <span class="keyword">switch</span>(action) &#123;</span><br><span class="line">        <span class="keyword">case</span> DragEvent.ACTION_DRAG_LOCATION:</span><br><span class="line">            <span class="keyword">return</span> onLocation(v, event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">onLocation</span><span class="params">(View v, DragEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前已经触发了切换Pager的动作，则不能马上继续切换，需要等待isScrolling置为false</span></span><br><span class="line">    <span class="keyword">if</span> (isScrolling) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// scrollWidthPx为触发切换Pager的区域宽度，比如为150px</span></span><br><span class="line">    <span class="keyword">boolean</span> isScrollToLeft = x &lt; scrollWidthPx &amp;&amp; currentIndex &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isScrollToRight = x &gt; w - scrollWidthPx &amp;&amp; currentIndex &lt; lastIndex;</span><br><span class="line">    <span class="keyword">if</span> (isScrollToLeft || isScrollToRight) &#123;</span><br><span class="line">        vp.setCurrentItem(isScrollToLeft ? currentIndex - <span class="number">1</span> : currentIndex + <span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">        isScrolling = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 延时scrollDelayedTime（可设置为1s）后设置isScrolling=false</span></span><br><span class="line">        handler.sendEmptyMessageDelayed(DelayedScrollHandler.MSG_SCROLL_END, scrollDelayedTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪代码，实际中需使用弱引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedScrollHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_SCROLL_END = <span class="number">1001</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.what == MSG_SCROLL_END) &#123;</span><br><span class="line">            isScrolling = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="缩放父视图而不改变子视图的动画"><a href="#缩放父视图而不改变子视图的动画" class="headerlink" title="缩放父视图而不改变子视图的动画"></a>缩放父视图而不改变子视图的动画</h1><p>实现一个视图的缩放动画是简单的，默认会缩放子视图。如果我们仅仅只缩放俯视图而要保持子视图的尺寸，则如何实现呢？有两种实现方法：</p>
<ol>
<li>利用属性动画ValueAnimator改变缩放值，在<code>AnimatorUpdateListener.onAnimationUpdate()</code>回调里实时更新父视图的MarginLayoutParams以及子视图的LayoutParams。这个方法在计算奇数除2时会导致1像素的损失而产生抖动现象，可以考虑使用浮点数，待以后验证 <strong>TODO</strong>。</li>
<li>同时利用属性动画ObjectAnimator对父视图和子视图同时缩放，但方向相反，如此子视图的尺寸能得到保持，动画流畅。</li>
</ol>
<p>两种方法的关键代码如下</p>
<p>方法一：利用属性动画ValueAnimator改变缩放值，存在画面抖动现象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Animator <span class="title">getKeepChildScaleAnimator</span><span class="params">(View from, <span class="keyword">final</span> View target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化参数...</span></span><br><span class="line">    <span class="comment">// 数值动画</span></span><br><span class="line">    ValueAnimator va = ValueAnimator.ofPropertyValuesHolder(widthProperty, heightProperty);</span><br><span class="line">    va.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 更新父视图尺寸</span></span><br><span class="line">            <span class="keyword">int</span> width = (<span class="keyword">int</span>) animation.getAnimatedValue(PROPERTY_SCALE_WIDTH);</span><br><span class="line">            <span class="keyword">int</span> height = (<span class="keyword">int</span>) animation.getAnimatedValue(PROPERTY_SCALE_HEIGHT);</span><br><span class="line">            <span class="comment">// todo 差为奇数时存在抖动 考虑使用float</span></span><br><span class="line">            <span class="keyword">int</span> deltaMarginTop = (targetHeight - height) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> deltaMarginLeft = (targetWidth - width) / <span class="number">2</span>;</span><br><span class="line">            ViewGroup.MarginLayoutParams lp = (ViewGroup.MarginLayoutParams) target.getLayoutParams();</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 更新子视图尺寸</span></span><br><span class="line">            ViewGroup vp = (ViewGroup) target;</span><br><span class="line">            View child = vp.getChildAt(<span class="number">0</span>);</span><br><span class="line">            ViewGroup.LayoutParams childLp = child.getLayoutParams();</span><br><span class="line">            childLp.width = width - target.getPaddingLeft() - target.getPaddingRight();</span><br><span class="line">            childLp.height = height - target.getPaddingTop() - target.getPaddingBottom();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> va;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：同时利用属性动画ObjectAnimator对父视图和子视图同时缩放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Animator <span class="title">getKeepChildScaleAnimator</span><span class="params">(View from, <span class="keyword">final</span> View target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// parent</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> scaleX = <span class="number">1.0f</span> * from.getWidth() / target.getWidth();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> scaleY = <span class="number">1.0f</span> * from.getHeight() / target.getHeight();</span><br><span class="line">    PropertyValuesHolder scaleXProperty = PropertyValuesHolder.ofFloat(<span class="string">&quot;scaleX&quot;</span>, scaleX, <span class="number">1</span>);</span><br><span class="line">    PropertyValuesHolder scaleYProperty = PropertyValuesHolder.ofFloat(<span class="string">&quot;scaleY&quot;</span>, scaleY, <span class="number">1</span>);</span><br><span class="line">    ValueAnimator va = ObjectAnimator.ofPropertyValuesHolder(target, scaleXProperty, scaleYProperty);</span><br><span class="line">    <span class="keyword">if</span> (! (target <span class="keyword">instanceof</span> ViewGroup)) &#123;</span><br><span class="line">        <span class="keyword">return</span> va;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// child</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> childScaleX = <span class="number">1.0f</span> / scaleX;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> childScaleY = <span class="number">1.0f</span> / scaleY;</span><br><span class="line">    PropertyValuesHolder childScaleXProperty = PropertyValuesHolder.ofFloat(<span class="string">&quot;scaleX&quot;</span>, childScaleX, <span class="number">1</span>);</span><br><span class="line">    PropertyValuesHolder childScaleYProperty = PropertyValuesHolder.ofFloat(<span class="string">&quot;scaleY&quot;</span>, childScaleY, <span class="number">1</span>);</span><br><span class="line">    ValueAnimator childVa = ObjectAnimator.ofPropertyValuesHolder(((ViewGroup) target).getChildAt(<span class="number">0</span>), childScaleXProperty, childScaleYProperty);</span><br><span class="line">    AnimatorSet set = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line">    set.playTogether(va, childVa);</span><br><span class="line">    <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ViewPager页面间拖动子视图更改位置的动画"><a href="#ViewPager页面间拖动子视图更改位置的动画" class="headerlink" title="ViewPager页面间拖动子视图更改位置的动画"></a>ViewPager页面间拖动子视图更改位置的动画</h1><p>我们希望能在ViewPager页面间拖动并改变页面里的View的位置，比如下图中，我们希望拖动当前Pager3中View-2到Pager2的View-2位置上，那么Pager2中View-2就会被挤到View-3的位置，View-3会被挤到Pager3中的View-1的位置，我们希望View-X的位置改变都以动画展示出来，其他动画比较容易实现，难点是如何在Pager2页面展示View-3被挤到Pager3中的动画，即View-3向右离开Pager2的动画。</p>
<p><img src="/images/android-launcher-customized-2.svg" alt="android-launcher-customized-2"></p>
<p>实现：由于最终的Pager2视图中是不会出现View-3的，因此需要使用一个额外的视图来表现View-3离开Pager2页面的动画，并在动画结束时移除View。</p>
<p>具体的方法也有两种：</p>
<ol>
<li>在应用级的Window里新增View并展示动画，最后发现动画会闪烁。待调查动画闪烁原因 <strong>TODO</strong></li>
<li>直接在Pager里添加View，并在动画结束时移除View。动画流程。</li>
</ol>
<p>关键代码如下</p>
<p>方法一：使用窗口展示动画</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动画有闪烁，不用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveSingleByAdditionWindow</span><span class="params">(View target, IItemInfo squeezeItemInfo, <span class="keyword">int</span> horizontalIndexDistance)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建窗口视图</span></span><br><span class="line">    <span class="keyword">final</span> View virtual = createVirtualView(squeezeItemInfo);</span><br><span class="line">    WindowManager wm = (WindowManager) target.getContext().getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    WindowManager.LayoutParams lp = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">    <span class="comment">// 设置LayoutParams...略</span></span><br><span class="line">    wm.addView(virtual, lp);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 通过ValueAnimator更新窗口LayoutParams</span></span><br><span class="line">    <span class="keyword">int</span> dx = horizontalIndexDistance * target.getWidth();</span><br><span class="line">    ValueAnimator va = ValueAnimator.ofInt(lp.x, lp.x + dx);</span><br><span class="line">    va.addUpdateListener(animation -&gt; &#123;</span><br><span class="line">        lp.x = (<span class="keyword">int</span>) animation.getAnimatedValue();</span><br><span class="line">        wm.updateViewLayout(virtual, lp);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动画结束时移除窗口视图</span></span><br><span class="line">    va.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            wm.removeView(virtual);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置透明动画</span></span><br><span class="line">    ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(virtual, <span class="string">&quot;alpha&quot;</span>, child.getAlpha(), <span class="number">0f</span>);</span><br><span class="line">    startSet(va, alphaAnim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：直接在Pager里添加View</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在父容器里直接添加view，动画完后再删除，动画效果流畅</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveVirtualSingleByAddRemove</span><span class="params">(View target, IItemInfo squeezeItemInfo, <span class="keyword">int</span> horizontalIndexDistance)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建View，并添加到父布局里</span></span><br><span class="line">    <span class="keyword">final</span> View virtualView = createVirtualView(...);</span><br><span class="line">    <span class="comment">// 动画</span></span><br><span class="line">    <span class="keyword">int</span> dx = horizontalIndexDistance * target.getWidth();</span><br><span class="line">    ObjectAnimator translationXAnim = ObjectAnimator.ofFloat(virtualView, <span class="string">&quot;translationX&quot;</span>, -dx, <span class="number">0f</span>);</span><br><span class="line">    <span class="comment">// 移除View</span></span><br><span class="line">    translationXAnim.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            removeVirtualView(...)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 透明动画</span></span><br><span class="line">    ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(virtualView, <span class="string">&quot;alpha&quot;</span>, child.getAlpha(), <span class="number">0f</span>);</span><br><span class="line">    startSet(translationXAnim, alphaAnim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/ui/drag-drop">官方文档-Drag And Drop</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangliangnbu.github.io/2022/01/05/auto-base-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="章亮">
      <meta itemprop="description" content="Developer For Android">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒的码流">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/05/auto-base-guide/" class="post-title-link" itemprop="url">车机开发基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-05 12:27:17" itemprop="dateCreated datePublished" datetime="2022-01-05T12:27:17+08:00">2022-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-06 09:28:14" itemprop="dateModified" datetime="2022-01-06T09:28:14+08:00">2022-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%A6%E6%9C%BA%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">车机开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>介绍实际车机开发中会用到的基础知识和概念，持续更新。</p>
<h1 id="CAN相关"><a href="#CAN相关" class="headerlink" title="CAN相关"></a>CAN相关</h1><blockquote>
<p>控制器局域网 (Controller Area Network，简称CAN或者CAN bus) 是一种功能丰富的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%BD%A6%E7%94%A8%E6%80%BB%E7%BA%BF&action=edit&redlink=1">车用总线</a>标准。</p>
</blockquote>
<p>CAN相关详细介绍请见<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8D%80%E5%9F%9F%E7%B6%B2%E8%B7%AF">维基百科</a>或百度百科。</p>
<p><strong>SoC借助MCU通过CAN与ECU的通信</strong></p>
<p><img src="/images/auto-soc-can-ecu.svg" alt="auto-soc-can-ecu"></p>
<p>SoC与MCU之间的交互可以使用目前比较流行的Protocol Buffer进行通信。</p>
<p><strong>CAN信号特点</strong></p>
<ul>
<li>SoC发送给ECU的设置类消息，一般为事件性的，单次触发，对应SoC的设置接口。</li>
<li>ECU发送给SoC的状态类消息，一般为周期性的，周期发送，对应SoC的回调接口。虽然为周期性发送，但MCU一般会处理，只有信号值改变时，才触发SoC的回调，因此对于SoC来说仅仅是有变更时才进行一次回调。</li>
<li>ECU一般很少提供给SoC获取接口，需要MCU或SoC自己缓存最新的数据，开发时需注意。</li>
</ul>
<h1 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h1><table>
<thead>
<tr>
<th>简写</th>
<th>全称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BAT</td>
<td>Battery</td>
<td>蓄电池，BAT+一般表示电池有电状态</td>
</tr>
<tr>
<td>ACC</td>
<td>Accessory</td>
<td>附件档，ACC-ON时可为部分车载附属设备供电，空调等除外。</td>
</tr>
<tr>
<td>IGN</td>
<td>Ignition</td>
<td>点火档，IGN-ON时，可为所有设备供电，包括空调</td>
</tr>
<tr>
<td>IVI</td>
<td>In-Vehicle Infotainment</td>
<td>车载娱乐信息系统，一般也表示车机SoC</td>
</tr>
<tr>
<td>HVAC</td>
<td>Heating, Ventilation and Air Conditioning</td>
<td>供热通风与空气调节，即空调</td>
</tr>
<tr>
<td>DVR</td>
<td>Drive Video Recorder</td>
<td>行车记录仪</td>
</tr>
<tr>
<td>HUD</td>
<td>Head-Up Display</td>
<td>抬头显示，在驾驶位正前方，一般与前车窗重合</td>
</tr>
<tr>
<td>M-CAN</td>
<td>Multimedia CAN</td>
<td>多媒体CAN协议</td>
</tr>
<tr>
<td>V-CAN</td>
<td>Vehicle CAN</td>
<td>车身CAN协议</td>
</tr>
<tr>
<td>RVC / RVM</td>
<td>Rear View Camera / Monitor</td>
<td>后方车辆摄像头或监控，一般称为倒车影像，包括实时路况显示和雷达信息显示（距离）</td>
</tr>
<tr>
<td>AVM</td>
<td>Around View Monitor</td>
<td>360度全景影像系统</td>
</tr>
</tbody></table>
<p>说明：</p>
<ul>
<li>档位与供电关系。时间先后：BAT+-&gt;ACC-ON-&gt;IGN-ON。首先蓄电池处于供电状态，然后可以开启ACC挡，为IVI供电等，最后开启IGN挡，可以开空调，并开动车辆。</li>
<li>倒车影像。通过远红外摄像获取车后路况图像，一般有有辅助线，是否一定是通过雷达系统获取距离信息来绘制的？</li>
<li>倒车雷达。通过超声波遇障碍物返回机制。可知晓车后障碍物距离信息，通过显示屏或蜂鸣器提示。一般由超声波传感器、控制器和显示器或蜂鸣器等组成。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers">Protocol Buffers</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infineon-autoeco.com/bbs/detail/9779#">汽车上的电源模块</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangliangnbu.github.io/2022/01/05/auto-navi-ar-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="章亮">
      <meta itemprop="description" content="Developer For Android">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒的码流">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/05/auto-navi-ar-guide/" class="post-title-link" itemprop="url">车载AR导航开发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-01-05 11:05:42 / 修改时间：12:15:46" itemprop="dateCreated datePublished" datetime="2022-01-05T11:05:42+08:00">2022-01-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%A6%E6%9C%BA%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">车机开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>车载AR导航机制一般为：首先利用摄像头将前方道路的真实场景实时捕捉下来，再结合汽车当前定位及传感器（陀螺仪、惯导）数据、地图导航信息以及场景AI识别，进行融合计算，然后生成虚拟的导航指引模型，并叠加到真实道路上，从而创建出更贴近驾驶者真实视野的导航画面。</p>
<p>车载AR导航系统需要实现的能力：</p>
<ul>
<li>车道级导航能力。基础导航能力。</li>
<li>图像获取、检测与识别能力。</li>
<li>AR融合算法能力。</li>
</ul>
<p>本文档主要介绍利用某导航SDK开发AR导航的流程（获取并传递图片）和注意事项，基础导航、图像的检测、AR融合算法皆由SDK提供。</p>
<h1 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h1><ul>
<li>基础导航。AR导航是基于基础导航的，基础导航的基本功能必须是完善的、没有问题的。</li>
<li>基于DR的定位模式。DR定位模式可以提高AR导航的精度，使得AR引导提示得更加精准。</li>
<li>摄像头。支持YUV格式帧流的摄像头（基本都支持），预览帧率必须不小于20fps（这个要根据具体SDK的AR服务要求来，我所使用的SDK中请求图片的帧率约为20fps）。</li>
<li>传感器。三轴陀螺仪、三轴加速度，其丢帧率和稳定性要符合SDK提供方的要求。</li>
<li>车身信息。车速信息、倒车信号、方向盘信息、车灯信息、雨刮器信息等。</li>
</ul>
<p>其他具体要求看SDK提供方的文档。</p>
<h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p>架构图如下</p>
<p><img src="/images/auto-navi-ar-dev.svg" alt="auto-navi-ar-dev"></p>
<p>说明：</p>
<ol>
<li>HMI通过摄像头获取路况预览帧流（Camera数据）、通过传感器获取加速度和陀螺仪信息（IMU数据）、通过车机接口获取车辆相关信息如方向盘等（Viechle数据）等，传给AutoSDK中ARService进行处理。</li>
<li>HMI通过卫星天线、传感器等获取定位、加速度、陀螺仪等信息传给AutoSDK中定位服务进行处理。</li>
<li>通过以上两步，SDK将AR图像替换底图并传递给HMI回调信息。</li>
</ol>
<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>主要流程为：查看摄像头参数、获取并缓存图片、传递图片、传递各种传感器和车身信息等。</p>
<p>本次开发中使用了罗技C270i USB摄像头，车机底层做了适配，因此可以直接用Android原生的Camera2相关接口开发。</p>
<h2 id="查看摄像头参数"><a href="#查看摄像头参数" class="headerlink" title="查看摄像头参数"></a>查看摄像头参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CameraManager manager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);</span><br><span class="line">StreamConfigurationMap map = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  摄像头支持的格式：</span></span><br><span class="line"><span class="comment">// 256 0x100 JPEG</span></span><br><span class="line"><span class="comment">// 34 0x22 PRIVATE</span></span><br><span class="line"><span class="comment">// 35 0x23 YUV_420_888 </span></span><br><span class="line"><span class="keyword">int</span>[] formats = map.getOutputFormats();</span><br><span class="line"></span><br><span class="line"><span class="comment">// YUV_420_888格式支持的像素尺寸:</span></span><br><span class="line"><span class="comment">// w/h= 864,480</span></span><br><span class="line"><span class="comment">// w/h= 640,360</span></span><br><span class="line"><span class="comment">// w/h= 800,448</span></span><br><span class="line"><span class="comment">// w/h= 800,600</span></span><br><span class="line"><span class="comment">// w/h= 640,480</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Size[] sizes = map.getOutputSizes(ImageFormat.YUV_420_888);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持的帧率：</span></span><br><span class="line"><span class="comment">// [[10, 30], [30, 30], [0, 0]]</span></span><br><span class="line">Range&lt;Integer&gt;[] fpsRanges = characteristics.get(CameraCharacteristics.CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES);</span><br></pre></td></tr></table></figure>

<h2 id="获取预览帧流"><a href="#获取预览帧流" class="headerlink" title="获取预览帧流"></a>获取预览帧流</h2><p>利用Camera2API获取摄像头预览帧流。</p>
<p>由于AR服务是通过回调请求图片，因此拍摄后的图片需要进行缓存，待AR回调时传给AR服务。可使用一个长度为2的队列进行缓存，要保证缓存数据为最新。队列长度不能太大，否则会造成较大的延时，也不能太小，否则会丢帧。</p>
<p>部分关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置ImageReader</span></span><br><span class="line"><span class="comment">// width和height可以设置成最终需要展示在车机屏幕上的宽高，摄像头会自动匹配宽高以及宽高比进行输出</span></span><br><span class="line"><span class="comment">// 格式为 ImageFormat.YUV_420_888</span></span><br><span class="line"><span class="comment">// 最大缓存图片数为2就足够了</span></span><br><span class="line">mImageReader = ImageReader.newInstance(width, height, ImageFormat.YUV_420_888, <span class="number">2</span>);</span><br><span class="line">mImageReader.setOnImageAvailableListener(mOnImageAvailableListener, mBackgroundHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置摄像头预览请求</span></span><br><span class="line">mPreviewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line"><span class="comment">// 用ImageReader来承接预览的帧</span></span><br><span class="line">mPreviewRequestBuilder.addTarget(mImageReader.getSurface());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在CameraCaptureSession.StateCallback#onConfigured回调里设置如下</span></span><br><span class="line"><span class="comment">// 设置自动聚焦连续拍照</span></span><br><span class="line">mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);</span><br><span class="line"><span class="comment">// 设置拍摄帧率</span></span><br><span class="line">mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE, <span class="keyword">new</span> Range&lt;&gt;(<span class="number">30</span>, <span class="number">30</span>));</span><br><span class="line"><span class="comment">// 请求重复拍照</span></span><br><span class="line">mCaptureSession.setRepeatingRequest(mPreviewRequest, mCaptureCallback, mBackgroundHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理图片</span></span><br><span class="line"><span class="comment">// 在ImageReader#setOnImageAvailableListener回调里可以获取图片，通过如下代码可查看图片信息</span></span><br><span class="line">Log.e(TAG, <span class="string">&quot;ImageSaver-run: &quot;</span> + <span class="string">&quot;format=&quot;</span> + mImage.getFormat() +</span><br><span class="line">        <span class="string">&quot;, width=&quot;</span> + mImage.getWidth() +</span><br><span class="line">        <span class="string">&quot;, height=&quot;</span> + mImage.getHeight() +</span><br><span class="line">        <span class="string">&quot;, plans count=&quot;</span> + mImage.getPlanes().length +</span><br><span class="line">        <span class="string">&quot;, timestamp=&quot;</span> + mImage.getTimestamp());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mImage.getPlanes().length; i ++) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;ImageSaver-run: &quot;</span> +</span><br><span class="line">            <span class="string">&quot;, plan-&quot;</span> + i +</span><br><span class="line">            <span class="string">&quot;, bufferSize=&quot;</span> + mImage.getPlanes()[i].getBuffer().remaining() +</span><br><span class="line">            <span class="string">&quot;, pixelStride&quot;</span> + mImage.getPlanes()[i].getPixelStride() +</span><br><span class="line">            <span class="string">&quot;, rowStride&quot;</span> + mImage.getPlanes()[i].getRowStride()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 图片转换 将拍摄的帧转换为AR服务能够接收的帧</span></span><br><span class="line"><span class="comment">// 这里需要匹配SDK需要的格式，不同的SDK要求不一样，但大同小异，基本信息基本一致</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ImageInfo <span class="title">parseToImageInfo</span><span class="params">(Image image)</span> </span>&#123;</span><br><span class="line">    ImageInfo info = <span class="keyword">new</span> ImageInfo();</span><br><span class="line">    info.type = IMAGE_TYPE.IMAGE_TYPE_YUV_420_888;</span><br><span class="line">    info.width = image.getWidth();</span><br><span class="line">    info.height = image.getHeight();</span><br><span class="line">    info.timeStamp = image.getTimestamp();</span><br><span class="line">    info.data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; image.getPlanes().length; i++) &#123;</span><br><span class="line">        Image.Plane plane = image.getPlanes()[i];</span><br><span class="line">        ByteBuffer buffer = plane.getBuffer();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">        buffer.get(bytes);</span><br><span class="line">        ImageChannel ic = <span class="keyword">new</span> ImageChannel(bytes, bytes.length, plane.getRowStride(), plane.getPixelStride());</span><br><span class="line">        info.data.add(ic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="根据SDK文档设置AR服务"><a href="#根据SDK文档设置AR服务" class="headerlink" title="根据SDK文档设置AR服务"></a>根据SDK文档设置AR服务</h2><ul>
<li>获取AR服务</li>
<li>设置资源代理，主要是AR引导图片、配置文件等</li>
<li>设置AR服务需要的摄像头参数</li>
<li>设置AR引擎需要在view中显示的大小</li>
<li>在AR服务回调里传入图片</li>
<li>设置IMU信息。导航过程中实时更新。</li>
<li>设置车辆状态信息：雨刮、档位、转向灯、方向盘。导航过程中实时更新。</li>
<li>等等</li>
</ul>
<p>具体代码就不贴了，不同SDK不一样，根据SDk文档来即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangliangnbu.github.io/2021/12/27/auto-navigation-system-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="章亮">
      <meta itemprop="description" content="Developer For Android">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒的码流">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/27/auto-navigation-system-guide/" class="post-title-link" itemprop="url">车载导航系统概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-27 17:27:42" itemprop="dateCreated datePublished" datetime="2021-12-27T17:27:42+08:00">2021-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-05 10:55:02" itemprop="dateModified" datetime="2022-01-05T10:55:02+08:00">2022-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%BD%A6%E6%9C%BA%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">车机开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前做了基于某流行的导航SDK开发车机导航App的项目，现在做一个总结，仅仅总结与特定导航无关的基础知识和概念。</p>
<p>车载导航系统由硬件和软件组合而成，按功能可划分为由定位系统、系统软件、导航应用软件等。定位系统包括GNSS天线、各种传感器、滤波器、DR模块等；系统软件目前较流行的是Android系统；导航应用软件即常说的某某导航App，正式名称为导航电子地图，可通过触摸显示屏或者语音等进行交互操作， 实现实时定位、 目的地检索、路线规划、画面和语音引导等功能，帮助驾驶者准确、快捷地到达目的地。</p>
<blockquote>
<p>车载导航与手机导航的最大的优势是，一，提供更加精准的定位，尤其是在GPS信号不好的时候，对比更加明显；二，更大的显示屏、更好的散热、更好的稳定性等。</p>
</blockquote>
<h1 id="定位系统"><a href="#定位系统" class="headerlink" title="定位系统"></a>定位系统</h1><p>在信号弱或者高速行驶时，仅依靠卫星定位是困难的，目前的定位不只是卫星定位，也会有硬件或软件的参与。硬件一般包括：GNSS信号接收机或称天线、DR微处理器（也可能由软件处理）、车速传感器、陀螺仪、加速度计等。 目前定位一般是通过包括GNSS信号在内的许多信号一起通过航位推算算法（DR）计算得到的，下图是DR模块位于硬件或软件系统中时的信号流程图，MMF表示地图匹配反馈信号。</p>
<p><img src="/images/auto-navi-dr.png" alt="auto-navi-dr"></p>
<p>目前普通民用 gps 和 dr 组合定位设备 (gps 惯性设备 ) 已经可以达到 1 000 m 无 gps 信号的情况下的航向精度和 10 m 的距离精度。</p>
<blockquote>
<p>车载天线接收GNSS信号的频率是有规定的，比如10Hz，频率太高对系统要求也会高，必定提高成本。10Hz的情况下，如果车速为36km/h（10m/s），间隔1m接收一次定位信号，似乎可以接收，如果车速为33m/s（120km/h)，则间隔3.3m才接收一次定位，对于一些路口区域，很容易错过。</p>
<p>航位推算：这种根据已知信息（当前位置、速度、加速度、方向等）推算经过一段时间后的位置的方法称为DR，dead reckoning。</p>
<p>卫星定位系统：一般称为全球导航卫星系统（ Global Navigation Satellite System，GNSS），GPS是美国的全球定位系统的简称，一般应该使用GNSS代表卫星定位或导航系统的总称。</p>
<p>陀螺仪：一般指三轴陀螺仪，是用于获取车辆三个轴向的角速度值，如果是单轴陀螺仪，则一般指Z轴，用来测量车辆的左右转向角度值。</p>
</blockquote>
<h1 id="地图匹配"><a href="#地图匹配" class="headerlink" title="地图匹配"></a>地图匹配</h1><p>地图匹配（Map Matching，简称MM）：将经过处理的信号中的位置、角度信息在实际道路线上显示出来的过程。我们认为车辆应该行驶在道路上，但实际信号的位置与角度一般不会跟道路数据吻合，所以需要选择一条与信号最为符合的道路段或路径段将车标展示在上面，此过程就称为地图匹配。 地图匹配的输入源包括信号与道路数据，地图匹配的输出结果为位置信息，包括经纬度、角度、速度等。</p>
<blockquote>
<p>实际场景中，手机自带 GPS 的定位精度在 10 米上下，单车道的宽度一般是 2-3 米。实际上，手机 GPS 定位不足以精确判断车辆行驶的实际道路。但大家会发现，通常情况下导航的道路定位都是很准确的，导航过程中地图会知道用户在某某道路而不是附近小区或者沟河中。</p>
<p>究其原因，用户导航过程中，系统一直在计算 GPS 位置和导航路线&amp;路网间的配准关系，从而进行一定程度的纠偏，这也是提高定位精度的重要手段。</p>
</blockquote>
<img src="/images/auto-map-match.jpg" width="70%" height="70%">

<p>地图匹配可分为两类：一类是导航和偏航，匹配非闭环路线；另一类为巡航，匹配路网。</p>
<p>地图匹配的核心是匹配算法，常见算法有离散点集匹配和曲线拟合：</p>
<ul>
<li>离散点集匹配。相对简单，随机离散点没有形状和拓扑关系，用欧氏距离作吸附即可，典型应用如离散热力图。效率低。</li>
<li>曲线拟合：评价曲线相似性的一般要素有长度、形状、曲率、拓扑关系、方向比如正向逆向、距离、属性例如交通规则左转右转禁行等信息。曲线拟合基于几何、拓扑、概率等可细分为多个方法。</li>
</ul>
<p>地图匹配反馈（Map-Matching Feedback）简称 MMF，将地图匹配的结果通知给 DR（推算及位置融合模块） 模块。</p>
<h1 id="导航电子地图"><a href="#导航电子地图" class="headerlink" title="导航电子地图"></a>导航电子地图</h1><p>用户最终看到的导航应用软件是由定位和地图共同组合的结果。导航电子地图包含的地图数据有道路数据（路段和节点）、 POI数据（特征点数据，兴趣点）、背景数据（建筑层、水系、植被）、行政区域数据、图形文件（高速出入口等）、语音文件等。其主要功能为地图显示、地图匹配、路线规划、路线引导等。</p>
<h1 id="路网与拓扑"><a href="#路网与拓扑" class="headerlink" title="路网与拓扑"></a>路网与拓扑</h1><p>现实世界中的道路是千变万化的，一般需要将这些道路抽象为基本的路段和节点（路网），再建立它们之间的拓扑关系，以实现地图匹配、路线规划等功能。路网的基本要素：点实体（节点）和线实体（路段）。</p>
<p><strong>路段</strong>。路段一般作为道路的最小空间描述单元，即路段是具有同一属性在路网中相互独立且最小的道路图形特征。路段属性有：编号、路段、长度、宽度、道路等级、最高速度限制、是否收费与收费标准、实时路况信息（交通事故、堵塞程度等）、允许车辆类型，等等。</p>
<blockquote>
<p>每一条道路，对应一些属性信息，例如道路的交通限制、道路名称、道路宽度等，所以需要根据属性信息的变化把一些道路拆分为更小的路段，现实世界里的一条道路一般会划分为多个路段。</p>
</blockquote>
<p><strong>节点</strong>。节点并不是一个实际意义上的点，它是一个抽象的概念，即可能使车辆行驶路线发生改变的控制点：</p>
<ul>
<li>道路的交叉口或者路的终点。</li>
<li>道路特性发生改变的点，如在该点道路的宽度显著增加或者减少，或者从该点开始道路需要收费行驶等。</li>
<li>可能进行转向操作的点，如进行物理分隔的道路中间将隔离栏(带)打开，专供车辆掉头的点。</li>
<li>快速路的出入口等。直接影响车辆导航系统路线计算的结果的点。</li>
</ul>
<p>常见节点：多道交叉口、环岛型交叉口、快速路的出入口、U型转弯口、道路连接点、复杂的立交桥等。</p>
<p>节点的属性有：编号、坐标、灯控路口的时间配时、节点的车辆行驶平均时间延误、交叉口转向限制等。</p>
<p><strong>路网拓扑结构</strong></p>
<p>路段之间的连接关系的表达即路段通过节点建立拓扑关系。建立拓扑关系的路网可以方便的执行地图匹配、路线规划等道路计算。</p>
<blockquote>
<p>拓扑，就是把实体抽象成与其大小、形状无关的“点”，而把连接实体的线路抽象成“线”，进而以图的形式来表示这些点与线之间关系的方法。其目的在于研究这些点、线之间的相连关系。表示点和线之间关系的图被称为拓扑结构图。</p>
</blockquote>
<p>常用模型为路段-链数据模型，基本思想：将路网的基本单元“路段”作为图的顶点，而将路段之间的允许转向行为（这种转向行为称作“链”）作为图的弧。</p>
<p><strong>导航路线与路段分析</strong></p>
<p>一个完整的导航路线（path），会被划分为多个聚合段（group segment），聚合段一般对应实际的道路；一个聚合段包括对应多个导航段（segment），导航段对应导航播报的基本单位，但未必对应最小的路段单位；导航段可以包含多个路段（link），路段表示道路的最小空间描述单元。用户关心的是导航段和聚合段。</p>
<ul>
<li>Link：路段，道路的最小描述单元。比如两个指示牌间的路段、路口与指示牌间的路段等、。</li>
<li>Segment：导航段，导航播报最小单元。两个转弯路口或道路有明显改变的节点之间的道路。</li>
<li>GroupSegment：聚合段，从一条路完全进入另外一条路之间的路段，与物理道路对应，但不一定完全对应。</li>
</ul>
<h1 id="地图和图层"><a href="#地图和图层" class="headerlink" title="地图和图层"></a>地图和图层</h1><p>目前的GIS软件都采用分层结构组织地图数据，把同一类或几类地理要素的信息放在同一个图层，整个地图数据按照图层-&gt;地图-&gt;地图集来组织，每个图层存储管理同类地图元素：</p>
<ul>
<li>地图集：地图集包含了导航软件所能加载的所有地图数据, 它是一个存放地图的容器。</li>
<li>地图：地图是通过地图集检索得到一个对象，它包含的是一个行政区划的地图数据。同时地图也是存放图层的一个容器。</li>
<li>图层：一个图层代表的是一种地图数据元素的集合。</li>
</ul>
<h1 id="其他相关概念"><a href="#其他相关概念" class="headerlink" title="其他相关概念"></a>其他相关概念</h1><h2 id="车辆坐标系"><a href="#车辆坐标系" class="headerlink" title="车辆坐标系"></a>车辆坐标系</h2><p>与机动车相关的坐标系有许多，常见的有：</p>
<ul>
<li>世界坐标系：用于描述车辆在世界的位置。</li>
<li>车辆坐标系：用于描述车辆的速度、旋转等，原点位于车辆中。</li>
<li>车内设备坐标系：比如车机的坐标系，用于描述设备自身的速度、角速度等，原点在设备中。</li>
<li>设备芯片：比如加速度计、陀螺仪等，用于描述芯片原始的值。原点在芯片中。</li>
</ul>
<p><img src="/images/auto-coordinate.jpg" alt="auto-coordinate"></p>
<p><strong>车辆坐标系</strong></p>
<p>由于XYZ坐标系不能很好地描述车辆的转动，因此一般用RPY（Roll-Pitch-Yaw）轴表示：</p>
<ul>
<li>Roll轴。滚转轴，轴正方向指向车辆前方，绕轴转动表示车辆在做滚转的动作。对应X轴或Y轴。</li>
<li>Pitch轴。俯仰轴，轴正方向指向车辆右侧，绕轴转动表示车辆在做俯仰的动作。对应Y轴或X轴。</li>
<li>Yaw轴。偏航轴，轴正方向指向车顶上方或车底下方，绕轴转动表示车辆在做偏航（转弯）的动作。对应Z轴。</li>
</ul>
<img src="/images/auto-directional-rotations.png" width="70%" height="70%">

<p>明确了轴正向方向后就可以确认正负值定义。对陀螺仪来说，需借助右手法则，拇指朝向轴正向，屈指方向为输出正值的方向；对加速度计来说，轴正向的加速度为正值。</p>
<p>一般设备芯片与车机的坐标系并不一致，而是存在角度差，称为安装角。安装角会导致传感器输出值计算过程中的误差，因此需要提前测出安装角并传给相关处理单元。</p>
<h2 id="加速度计"><a href="#加速度计" class="headerlink" title="加速度计"></a>加速度计</h2><p>加速度计（Accelerometer），用于获取车辆三个轴向的加速度值，常见三轴数值规定如下：</p>
<ul>
<li>Roll轴。车尾指向车头    车辆向前加速输出变大，刹车输出变小</li>
<li>Pitch轴。车左侧指向车右侧，车辆向右横移输出变大，向左横移输出变小</li>
<li>Yaw轴。车底指向车顶，车辆水平静止，输出+1.0；垂直向上加速，输出大于+1.0；垂直向下加速，输出小于+1.0。静止时的1.0表示一个重力加速度g。</li>
</ul>
<h2 id="陀螺仪"><a href="#陀螺仪" class="headerlink" title="陀螺仪"></a>陀螺仪</h2><p>陀螺仪（Gyroscope），用来测量角速度或保持方向器具。它是一个旋转的轮子或圆盘，其中的自旋轴可以是任何方向。根据角动量守恒，当旋转时，自旋轴的方向不受影响。一般指三轴陀螺仪，是用于获取车辆三个轴向的角速度值，如果是单轴陀螺仪，则一般指Z轴，用来测量车辆的左右转向角度值。</p>
<p>陀螺仪零偏。指陀螺仪在无外部输入（车辆静止或匀速直线行驶）状态下，所输出的值不等于0的状态，零偏亦指这种状态下输出的误差值。</p>
<p>陀螺仪温漂。指陀螺仪零偏随着传感器本身温度不同而变化的特性。</p>
<p>陀螺仪轴向验证。</p>
<h2 id="航向"><a href="#航向" class="headerlink" title="航向"></a>航向</h2><p>中文里航向对应英文里的Course或Heading，但这二者是有区别的：</p>
<ul>
<li>Course。表示机车（或飞机或船）的实际航行轨迹的方向，是机车本身的速度、风速等叠加后的合速度的方向。</li>
<li>Heading。仅仅指机车（或飞机或船）车头指向的方向。</li>
</ul>
<img src="/images/auto-heading-course.png" width="30%" height="30%">

<p>上图中AB是飞机的Heading方向，由于风速的影响，飞机的航向偏移到AC方向即Course。一般意义上，中文里航向指的就是Course，实际航行的路径方向。</p>
<h2 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h2><table>
<thead>
<tr>
<th>术语缩写</th>
<th>全称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>EGL</td>
<td>Embedded Graphics Library</td>
<td>嵌入图形库</td>
</tr>
<tr>
<td>GPS</td>
<td>Global Positioning System</td>
<td>美国的全球定位系统</td>
</tr>
<tr>
<td>GNSS</td>
<td>Global Navigation Satellite System</td>
<td>全球导航卫星系统</td>
</tr>
<tr>
<td>HMI</td>
<td>Human Machine Interface</td>
<td>人机交互接口，通常指SDK之上的开发</td>
</tr>
<tr>
<td>POI</td>
<td>Point of Interest</td>
<td>兴趣点</td>
</tr>
<tr>
<td>TBT</td>
<td>Turn By Turn</td>
<td>逐向导航</td>
</tr>
<tr>
<td>TMC</td>
<td>Traffic Message Channel</td>
<td>交通实时信息频道</td>
</tr>
<tr>
<td>TTS</td>
<td>Text To Speech</td>
<td>从文本到语音</td>
</tr>
<tr>
<td>TR</td>
<td>Traffic Radar</td>
<td></td>
</tr>
<tr>
<td>MM</td>
<td>Map-Matching</td>
<td>地图匹配</td>
</tr>
<tr>
<td>SA/PA</td>
<td>Server Area / Parking Area</td>
<td>服务区、停车区</td>
</tr>
<tr>
<td>DR</td>
<td>Dead Reckoning</td>
<td>航位推算</td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Satellite_navigation">维基百科-卫星导航</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Satellite_constellation">维基百科-卫星星座</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%AA%E8%B7%9D">维基百科-伪距</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/GNSS_positioning_calculation#Note">维基百科-GNSS定位计算</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/11">地图匹配实践</a></li>
<li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/axrxvv5h801wkkhekdov">地图数据处理之道路匹配篇</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83039334">车辆轨迹地图匹配（Map-Matching）</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Course_(navigation)">Wikipedia - Course (navigation)</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Heading_(navigation)">Wikipedia - Heading (navigation)</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangliangnbu.github.io/2021/12/23/android-ui-system-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="章亮">
      <meta itemprop="description" content="Developer For Android">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒的码流">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/23/android-ui-system-guide/" class="post-title-link" itemprop="url">Android图形系统概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-23 17:01:27" itemprop="dateCreated datePublished" datetime="2021-12-23T17:01:27+08:00">2021-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-27 15:19:36" itemprop="dateModified" datetime="2021-12-27T15:19:36+08:00">2021-12-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Android系统开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>当我们调用<code>TextView.setTextColor()</code>之后，UI就会更新，这一过程是怎样的？本文通过较完整的视图绘制流程分析Android的图形系统。</p>
<blockquote>
<p>这里的绘制流程是指UI从数据更改触发到最终更新的流程。</p>
</blockquote>
<p>代码基于Android 10。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>对于Android图形系统，可以这样理解：App中我们见到状态栏、Activity界面、弹窗等都是一个个窗口，对应App端的Window和服务端的WindowState；每个窗口包含多个控件，对应View和ViewGroup；每个窗口独占单独的画布，对应Surface（持有Canvas）；多个画布内容通过SurfaceFlinger合成一帧画面，最后通过显示设备输出。</p>
<blockquote>
<p>说得比较粗糙，实际情况较复杂，待以后优化 <strong>TODO</strong></p>
</blockquote>
<p>简单的对应关系如图：</p>
<p><img src="/images/wms-client-server-ui.svg" alt="wms-client-server-ui"></p>
<p>Window和WindowState都间接持有Surface的引用，WindowState持有与SurfaceFlinger的连接Session。可通俗理解为，多个View控件构成一个Surface内容，多个Surface内容通过SurfaceFlinger合成为一帧最终输出的图像。</p>
<p>下面以具体代码来分析Android图形系统，分析<code>TextView.setTextColor()</code>从调用到UI更新的调用链流程，可分为：</p>
<ul>
<li>准备阶段：计算脏区位置和宽高（Dirty Rect，就是待更新区域）、测量、布局，之后调用<code>ViewRootImpl.performDraw()</code>尝试硬件绘制，不能或不成功则进行软件绘制。</li>
<li>绘制操作：区分软件绘制和硬件绘制，绘制数据有所差别，但最终都是将绘制数据填充到GraphicBuffer，通知SurfaceFlinger进行合成。</li>
<li>合成展示：SurfaceFlinger利用硬件(OpenGL 和 HardWare Composer)将 GraphicBuffer 数据合成并交给Display Buffer去显示。</li>
</ul>
<p>整个流程如下：</p>
<p><img src="/images/android-draw-total-flow.svg" alt="android-draw-total-flow"></p>
<blockquote>
<p>这幅图参考<a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/11/09/Android-Surface%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Android-Surface原理解析</a>，图例比较清晰全面，我直接拿过来并重新绘制了全图。</p>
</blockquote>
<h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>准备阶段时序图如下：</p>
<p><img src="/images/android-set-text-color-sq.svg" alt="android-set-text-color-sq"></p>
<blockquote>
<p>略繁琐，逻辑不够清晰，待以后更新 <strong>TODO</strong></p>
</blockquote>
<p>大致流程为：首先计算脏区尺寸和位置，之后调用<code>ViewRootImpl.performTraversals()</code>进行测量、布局和绘制操作。</p>
<h2 id="计算脏区在屏幕中的位置和宽高"><a href="#计算脏区在屏幕中的位置和宽高" class="headerlink" title="计算脏区在屏幕中的位置和宽高"></a>计算脏区在屏幕中的位置和宽高</h2><p>计算时会调用<code>ViewGroup.invalidateChild()</code>遍历当前View的所有的<code>ViewParent</code>，直到<code>ViewRootImpl</code>为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewGroup.java</span></span><br><span class="line"><span class="comment">// 这个child是实例中待更新的TextView</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invalidateChild</span><span class="params">(View child, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line">    ViewParent parent = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] location = attachInfo.mInvalidateChildLocation;</span><br><span class="line">    location[CHILD_LEFT_INDEX] = child.mLeft;</span><br><span class="line">    location[CHILD_TOP_INDEX] = child.mTop;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的ViewParentt以计算脏区. 首先进入ViewGroup，最后进入ViewRootImpl</span></span><br><span class="line">        parent = parent.invalidateChildInParent(location, dirty);</span><br><span class="line">    &#125; <span class="keyword">while</span> (parent != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测量视图树中所有View的宽高"><a href="#测量视图树中所有View的宽高" class="headerlink" title="测量视图树中所有View的宽高"></a>测量视图树中所有View的宽高</h2><p>在<code>ViewRootImpl.performTraversals()</code>中会依次调用<code>performMeasure()</code>、<code>performLayout()</code>、<code>performDraw()</code>三个主要方法。<code>performMeasure()</code>即测量。测量的工作是确定View的宽高，测量的主要规则通过父布局的MeasureSpec确定子View的宽高。</p>
<p>详细流程：首先确定根View的MeasureSpec；然后通过父布局的MeasureSpec确定子View的MeasureSpec；最后在onMeasure方法中根据这个MeasureSpec来确定View的测量宽高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的mView指根View, 一般为DecorView</span></span><br><span class="line">	mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ViewGroup控件调用 ViewGroup.onMeasure(), 非ViewGroup调用View.onMeasure()</span></span><br><span class="line">    onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>在<code>ViewRootImpl.performTraversals()</code>中<code>performLayout()</code>执行布局。<strong>TODO</strong></p>
<p>之后，在<code>ViewRootImpl.performDraw()</code>中首先尝试硬件绘制，不能或不成功则软件绘制。软件绘制会调用<code>ViewRootImpl.drawSoftware</code>，其中会通过<code>Surface</code>生成<code>Canvas</code>以传递给视图树使用。</p>
<h1 id="绘制阶段"><a href="#绘制阶段" class="headerlink" title="绘制阶段"></a>绘制阶段</h1><h2 id="Surface的创建"><a href="#Surface的创建" class="headerlink" title="Surface的创建"></a>Surface的创建</h2><p>绘制流程中涉及到Surface，有必要先描述Surface相关对象的创建。相关对象有：SurfaceSession、SurfaceControl和Surface。这三个对象的Java层实例都持有其Native层的指针，实际绘制工作最终都由Native层完成。</p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>SurfaceSession是App端与SurfaceFlinger的连接，可用于创建的SurfaceControl，后者用于创建Surface。</p>
<blockquote>
<p>这里说的创建对象，包括Java层和Native层</p>
</blockquote>
<p>在 Java 层 ViewRootImpl 实例中持有一个 Surface 对象，该 Surface 对象中的 mNativeObject 属性指向 native 层中创建的 Surface 对象，native 层的 Surface 对应 SurfaceFlinger 中的 Layer 对象，它持有 Layer 中对应的 BufferQueueProducer 生产者指针，在 Surface 上绘制的内容最终会交由 SurfaceFlinger 来合成渲染送到显示器显示。</p>
<p>创建过程中，涉及到的Java层和Native层的类：</p>
<p><img src="/images/android-surface-create-class-uml.svg" alt="android-surface-create-class-uml"></p>
<h3 id="SurfaceSession"><a href="#SurfaceSession" class="headerlink" title="SurfaceSession"></a><strong>SurfaceSession</strong></h3><p>代表Surface与SurfaceFlinger 的连接，通过该连接可以创建多个Surface实例；持有客户端SurfaceComposerClient的指针，连接的实现由其实现，可用于创建SurfaceControl。</p>
<p>SurfaceSession对象是在Window添加流程中创建的，在<code>WMS.addWindow() </code>方法中创建 WindowState，它会调用<code>WindowState.attach()</code>方法，该方法内调用<code>Session.windowAddedLocked()</code>，在这里创建Java端的SurfaceSession对象。SurfaceSession构造方法会通过JNI创建一个 Native端的SurfaceComposerClient 对象，后者又创建了一个 实现了ISurfaceComposerClient接口的Client 对象，通过此对象与SurfaceFlinge通信。</p>
<p>创建的时序图：</p>
<p><img src="/images/android-surface-create-sq-flow-16403397442681.svg" alt="android-surface-create-sq-flow"></p>
<p>相关代码：由于涉及C++代码，稍微贴下较详细的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Session.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">windowAddedLocked</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">    mSurfaceSession = <span class="keyword">new</span> <span class="built_in">SurfaceSession</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceSession.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mNativeClient; <span class="comment">// SurfaceComposerClient*</span></span><br><span class="line"><span class="comment">// 创建与Surface Flinger的连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SurfaceSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mNativeClient = <span class="built_in">nativeCreate</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_SurfaceSession.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    SurfaceComposerClient* client = <span class="keyword">new</span> <span class="built_in">SurfaceComposerClient</span>();</span><br><span class="line">    client-&gt;<span class="built_in">incStrong</span>((<span class="keyword">void</span>*)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用incStrong函数时，如果SurfaceComposerClient是第一次被引用则会调用onFirstRef()函数</span></span><br><span class="line"><span class="comment">// frameworks/native/libs/gui/SurfaceComposerClient.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceComposerClient::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从服务端(surface flinger)获取服务</span></span><br><span class="line">    <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sf</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line">    <span class="comment">// 通过服务创建连接</span></span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; conn = sf-&gt;<span class="built_in">createConnection</span>();</span><br><span class="line">    mClient = conn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function">sp&lt;ISurfaceComposerClient&gt; <span class="title">SurfaceFlinger::createConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initClient方法只是调用initCheck检查了一下</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">initClient</span>(<span class="keyword">new</span> <span class="built_in">Client</span>(<span class="keyword">this</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SurfaceControl"><a href="#SurfaceControl" class="headerlink" title="SurfaceControl"></a><strong>SurfaceControl</strong></h3><p>用于Surface的创建等管理。</p>
<p>客户端ViewRootImpl中持有一个SurfaceControl，但开始是无内容无效的，没有持有Native层对象的指针。<code>ViewRootImpl.performTraversals()</code>中会调用<code>ViewRootImpl.relayoutWindow()</code>方法，之后会通过Session将此SurfaceControl传给WMS，WMS创建WindowSurfaceController对象，该对象构造器内部创建并持有新的SurfaceControl实例，它通过<code>nativeCreate()</code>方法创建底层实例即客户端的SurfaceControl以及SurfaceFlinger端的Layer，并持有底层SurfaceControl的指针。</p>
<p>另外：创建SurfaceControl流程中会创建surface flinger端的layer对象：BufferQueueLayer，并创建它的两个重要成员：BufferQueueProducer 和 BufferQueueConsumer的包装类对象。SurfaceControl和Surface持有Layer中对应的BufferQueueProducer指针，只负责生产数据流。</p>
<p>创建的时序图如下：</p>
<p><img src="/images/android-surface-control-create-sq-flow.svg" alt="android-surface-control-create-sq-flow"></p>
<p>关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要进行布局操作时</span></span><br><span class="line">    relayoutWindow(params, viewVisibility, insetsPending)</span><br><span class="line">    <span class="comment">// measure, layout, draw</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createSurfaceControl</span><span class="params">(SurfaceControl outSurfaceControl...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最终通过SurfaceSession创建SurfaceControl, 并创建Native层对象</span></span><br><span class="line">    WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_SurfaceControl.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(jobject sessionObj, ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sessionObj 即SurfaceSession，在Window添加流程中已创建</span></span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client = android_view_SurfaceSession_getClient(...sessionObj);;</span><br><span class="line">    <span class="comment">// 创建SurfaceControl, 最终通过Native层的连接ISurfaceComposerClient创建</span></span><br><span class="line">    client-&gt;createSurfaceChecked(..., &amp;surface, ..., parent, ...));</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/libs/gui/SurfaceComposerClient.cpp</span></span><br><span class="line">status_t SurfaceComposerClient::createSurfaceChecked() &#123;</span><br><span class="line">    <span class="comment">// 这里的mClient是指接口ISurfaceComposerClient, 详情见上面SurfaceSession创建流程</span></span><br><span class="line">    status_t err = mClient-&gt;createSurface(..., &amp;gbp);</span><br><span class="line">    *outSurface = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp, <span class="keyword">true</span> <span class="comment">/* owned */</span>);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/Client.cpp</span></span><br><span class="line">status_t Client::createSurface(...sp&lt;IGraphicBufferProducer&gt;* gbp) &#123;</span><br><span class="line">    <span class="comment">// 通过SurfaceFlinger创建Layer</span></span><br><span class="line">    <span class="keyword">return</span> mFlinger-&gt;createLayer(...handle, gbp, parentHandle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h3><p>在<code>ViewRootImpl.relayoutWindow()</code>中，首先调用<code>mWindowSession.relayout()</code>生成并初始化SurfaceControl，接着在Native 层中，通过SurfaceControl创建Surface，并将地址指针赋值给Java层Surface的mNativeObject成员。</p>
<p><img src="/images/android-surface-self-create-sq-flow.svg" alt="android-surface-self-create-sq-flow"></p>
<p>关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化SurfaceControl</span></span><br><span class="line">    mWindowSession.relayout(mWindow,...,mSurfaceControl,...);</span><br><span class="line">    <span class="comment">// 按理说Binder通信会copy数据，但最最终是否会修改此处的mSurfaceControl？</span></span><br><span class="line">    <span class="comment">// 如果此处不修改，又在何处修改呢，找不出明确修改mSurfaceControl的地方，但感觉应该修改了</span></span><br><span class="line">    mSurface.copyFrom(mSurfaceControl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_Surface.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeGetFromSurfaceControl</span><span class="params">(...jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line">    Surface* self(reinterpret_cast&lt;Surface *&gt;(nativeObject));</span><br><span class="line">    <span class="function">sp&lt;SurfaceControl&gt; <span class="title">ctrl</span><span class="params">(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj)</span>)</span>;</span><br><span class="line">    <span class="comment">// 首次需要创建</span></span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(ctrl-&gt;getSurface()</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/libs/gui/SurfaceControl.cpp</span></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::generateSurfaceLocked() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// gbp在SurfaceControl时已创建</span></span><br><span class="line">    mSurfaceData = <span class="keyword">new</span> Surface(mGraphicBufferProducer, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="绘制操作"><a href="#绘制操作" class="headerlink" title="绘制操作"></a>绘制操作</h2><p>绘制即在Android APP 进程中将 UI 绘制到一个图形缓冲区 GraphicBuffer 中的过程。绘制操作包括两种实现方式：软件绘制和硬件绘制（也叫硬件加速，下面统一称为硬件绘制）。硬件绘制会使用 GPU将图形 加速渲染到 GraphicBuffer 。</p>
<p>绘制入口为<code>ViewRootImpl.draw()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">        mAttachInfo.mThreadedRenderer.draw(mView ...); <span class="comment">// 硬件绘制</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        drawSoftware(surface, ...) <span class="comment">// 软件绘制</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> useAsyncReport;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><strong>软件绘制</strong></p>
<p>当 App 更新部分 UI 时，CPU 会遍历 View Tree 计算出需要重绘的脏区，接着在 View 层次结构中绘制所有跟脏区相交的区域，之后将绘制的内容写进一个 Bitmap 位图，这个 Bitmap 的像素内容会填充到 Surface 的缓存区里。软件绘制使用 Skia 库。</p>
<p>缺点：可能重绘无需更新的视图；主线程绘制容易造成卡顿情况。</p>
<p><strong>硬件绘制</strong></p>
<p>当 App 更新部分 UI 时，CPU 会计算出脏区，但是不会立即执行绘制命令，而是将 drawXXX 函数作为绘制指令(DrawOp)记录在一个列表(DisplayList)中，然后交给单独的 Render 线程使用 GPU 进行硬件加速渲染。</p>
<p>硬件绘制使用 OpenGL 在 GPU 上完成，OpenGL 是跨平台的图形 API，为 2D/3D 图形处理硬件制定了标准的软件接口。Skia 已接手 OpenGL，实现间接统一调用。</p>
<p>优点：</p>
<ol>
<li>无需重绘所有相交区域。只需要针对需要更新的 View 对象的脏区进行记录或更新，无需更新的 View 对象则能重用先前 DisplayList 中记录的指令。</li>
<li>单独线程绘制可缓解卡顿情况。硬件加速是在单独的 Render 线程中完成绘制的，分担了主线程的压力，提高了响应速度。</li>
</ol>
<p>缺点：兼容性（部分绘制函数不支持加速），内存消耗，电量消耗（GPU耗电）等。</p>
<blockquote>
<p> 从 Android 3.0(API 11)开始支持硬件加速，Android 4.0(API 14)默认开启硬件加速。</p>
</blockquote>
<p>配置硬件绘制：</p>
<ul>
<li>Application: 在 Manifest 文件的 application 标签添加 <code>android:hardwareAccelerated=&quot;boolean&quot;</code></li>
<li>Activity: 在 Manifest 文件的 activity 标签添加 <code>android:hardwareAccelerated=&quot;boolean&quot;</code></li>
<li>Window: <code>getWindow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED)</code></li>
<li>View: <code>setLayerType(View.LAYER_TYPE_HARDWARE/*View.LAYER_TYPE_SOFTWARE*/, mPaint)</code></li>
</ul>
<h3 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h3><p>软件绘制的入口为<code>ViewRootImpl.drawSoftware()</code>，可以简单分为三个步骤：</p>
<ol>
<li><code>Surface.lockCanvas </code>方法通过 <code>BufferQueueProducer.dequeueBuffer()</code> 函数从 BufferQueue 中取出一个图形缓存区 GraphicBuffer(用来创建 Canvas 中的 Bitmap 对象) 并锁定该Surface，然后将 Surface 的地址返回给 Java 层 Surface 中的 mLockedObject属性。在这个方法中还会涉及到 Surface 的双缓冲逻辑。</li>
<li>调用 <code>View.draw()</code> 方法将内容绘制到 Canvas 对应的 Bitmap 中，其实就是往上面的图形缓存区 GraphicBuffer 填充绘制数据。</li>
<li><code>Surface.unlockCanvasAndPost()</code> 方法通过调用被锁定的 <code>surface-&gt;unlockAndPost()</code> 方法解锁 Surface 且通过 <code>queueBuffer()</code> 函数将填充了数据的图形缓存区 GraphicBuffer 存入 BufferQueue 队列中，然后通知给 SurfaceFlinger 进行合成(请求 Vsync 信号)。</li>
</ol>
<p>对于软件绘制中的 Canvas 而言其绘制目标是一个 Bitmap 对象，绘制的内容会填充到 Surface 持有的缓存区(GraphicBuffer)里。</p>
<p><strong>简单流程即：GraphicBuffer出队→写数据到Bitmap中→GraphicBuffer入队合成。</strong></p>
<blockquote>
<p>待补流程图 <strong>TODO</strong> </p>
</blockquote>
<h3 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h3><p>硬件加速可以从两个阶段来看：</p>
<ol>
<li>构建阶段：将 View 抽象成 RenderNode 节点，将每个绘制操作(drawLine等)抽象成 DrawOp，它保存了绘制数据并与 OpenGL 绘制命令对应。这个阶段会递归遍历所有 View 并通过 Canvas.drawXXX将绘制操作转化成 DrawOp 存入 DisplayList 中，根据 ViewTree 模型，这个 DisplayList 虽然命名为List，但其实更像一棵树。</li>
<li>绘制阶段：通过单独的 Render 线程，依赖 GPU 绘制上面的 DrawOp 数据。其中硬件加速的内存申请跟软件绘制一样都是借助 Layer 中的 BufferQueueProducer 生产者从 BufferQueue 中出队列一块空闲缓存区 GraphicBuffer 用来渲染数据的，之后也都会通知 SurfaceFlinger 进行合成。不一样的地方在于硬件加速相比软件绘制而言算法可能更加合理，同时采用了一个单独的 Render 线程，减轻了主线程的负担。</li>
</ol>
<h3 id="绘制中的双缓冲"><a href="#绘制中的双缓冲" class="headerlink" title="绘制中的双缓冲"></a>绘制中的双缓冲</h3><p>一般来说将双缓冲用到的两块缓冲区称为 – 前缓冲区(front buffer) 和 后缓冲区(back buffer)。显示器显示的数据来源于front buffer 前缓存区，而每一帧的数据都绘制到 back buffer 后缓存区，在 Vsync信号到来后会交互缓存区的数据(指针指向)，这时 front buffer 和 back buffer 的称呼及功能倒转。</p>
<p><strong>软件绘制中的双缓冲</strong></p>
<p><code>Surface.lock()</code>:</p>
<ol>
<li>将出队列的空闲缓存区 GraphicBuffer 赋给后缓存区 backBuffer，将正在显示的 mPostedBuffer 赋给前缓存区。</li>
<li>计算新的脏区，并确定是否需要将前缓存区拷贝到后缓存区，依此计算出后缓存区 backBuffer 的最终数据。然后将 backBuffer 与应用层的 Canvas 关联，当操作 Canvas 绘图时会将数据绘制到 backBuffer 上。</li>
<li>锁定 backBuffer 且将 backBuffer 指针赋值给 mLockedBuffer。</li>
</ol>
<p><code>Surface.unlockAndPost()</code>:</p>
<ol>
<li>将存有绘制数据的 mLockedBuffer 解锁并将其赋值给 mPostedBuffer。</li>
<li>将 mLockedBuffer 入 BufferQueue 队列，等待被合成显示，在这里便相当于交换了前后缓冲区的指针，等到下次绘制时，接着重复上面的步骤。</li>
</ol>
<p><strong>硬件绘制中的双缓冲</strong></p>
<p>硬件绘制最终会调用 CanvasContext.draw 方法来绘制，也用到双缓冲。略… <strong>TODO</strong></p>
<h1 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h1><p>待更新 <strong>TODO</strong></p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>写的太长，累(⊙o⊙)…准备阶段缺少测量和布局流程、绘制缺少时序图和关键代码，合成和显示缺少整个章节，待以后慢慢整理、补充。</p>
<p>另外说明的是，我的文章仅仅从UI更新的流程这一个角度来分析Android图形系统，依旧不全面，一些偏底层的部分涉及较少，详细情况可参考官方的文档：<a target="_blank" rel="noopener" href="https://source.android.google.cn/devices/graphics?hl=zh-cn#android-graphics-components">Android 图形概览</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://source.android.google.cn/devices/graphics?hl=zh-cn#android-graphics-components">Android 图形概览</a></li>
<li><a target="_blank" rel="noopener" href="http://aospxref.com/android-10.0.0_r47/">Android 10 源码</a></li>
<li><a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/11/09/Android-Surface%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">三方博客：Android-Surface原理解析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/solomarge/p/14325080.html">三方博客：C++中sp和wp</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/268894227">三方博客：C++创建对象时区分圆括号( )和大括号{ }</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangliangnbu.github.io/2021/12/20/android-activity-bind-ui-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="章亮">
      <meta itemprop="description" content="Developer For Android">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒的码流">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/20/android-activity-bind-ui-guide/" class="post-title-link" itemprop="url">Activity绑定视图流程概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-20 15:59:11" itemprop="dateCreated datePublished" datetime="2021-12-20T15:59:11+08:00">2021-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-23 16:58:11" itemprop="dateModified" datetime="2021-12-23T16:58:11+08:00">2021-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Android系统开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>我们在<code>Activity.onCreate()</code>方法里调用<code>setContentView()</code>方法后，待Activity处于RESUME状态时就会呈现视图。这一过程涉及到Activity的启动以及视图的创建和绘制，那么Activity是如何与视图(Window、View)产生联系或绑定在一起的？</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>流程关键节点：</p>
<ul>
<li>启动Activity。<code>Activity.startActivity()</code>。</li>
<li>创建窗口。Activity启动流程中会调用<code>ActivityThread.performLaunchActivity()</code>方法，该方法内部通过<code>Activity.attach()</code>方法创建PhoneWindow实例，并与Activity绑定。</li>
<li>创建视图树。<code>ActivityThread.performLaunchActivity()</code>方法中待创建PhoneWindow后，接着会执行<code>Instrumentation.callActivityOnCreate()</code>、<code>Activity.onCreate()</code>, 最终会调用<code>Activity.setContentView()</code>解析视图树并与Window绑定。</li>
<li>绘制视图。在Activity启动流程的方法<code>ActivityStackSupervisor.realStartActivityLocked()</code>中会依次添加<em>Launch</em>和<em>Resume</em>事务，待执行完<code>ActivityThread.performLaunchActivity()</code>等<em>Launch</em>方法后，会接着执行<code>ActivityThread.handleResumeActivity()</code>等<em>Resume</em>方法，该方法内部通过<code>WindowManager.addView()</code>方法绘制视图呈现UI。</li>
</ul>
<p>简略时序图如下：</p>
<p><img src="/images/android-activity-bind-ui-flow.png"></p>
<p>经过上面的流程，最终在App中视图相关的各类对象间关系为：</p>
<ul>
<li>Activity持有PhoneWindow引用，PhoneWindow持有视图树根节点DecorView引用，DecorView对象又持有抽象根节点ViewRootImpl。</li>
<li>ViewRootImpl由WindowManagerGlobal创建和管理，而它自身管理视图树的绘制。</li>
<li>ViewRootImpl通过Session与WindowManagerService建立联系，由服务端管理窗口。</li>
<li>Activity、PhoneWindow、DecorView、ViewRootImpl、Session和WindowState是一一对应关系。</li>
<li>WindowManagerGlobal为单例，App进程全局唯一。</li>
</ul>
<p><img src="/images/android-window-view-relation.svg"></p>
<p>上面的箭头表示有联系，直接持有引用或间接联系。</p>
<h1 id="启动Activity"><a href="#启动Activity" class="headerlink" title="启动Activity"></a>启动Activity</h1><p>Activity的启动流程见我的博客：<a href="/2021/12/17/android-activity-start-guide/" title="Andoird 10 Activity启动流程概览">Andoird 10 Activity启动流程概览</a></p>
<h1 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h1><p>在<code>Activity.attach()</code>方法创建PhoneWindow实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有保存的window时，window为空</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PhoneWindow</span><span class="params">(Context context, Window preservedWindow...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有保存的window时，直接绑定之前的DecorView</span></span><br><span class="line">    <span class="keyword">if</span> (preservedWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = (DecorView) preservedWindow.getDecorView();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PhoneWindow对象实例化时，先判断是否有缓存window时，有就直接绑定之前的DecorView，DecorView是视图树的根节点；没有缓存window则会在之后的<code>Activity.setContentView()</code>时绑定DecorView。</p>
<h1 id="创建视图树"><a href="#创建视图树" class="headerlink" title="创建视图树"></a>创建视图树</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>在<code>Activity.setContentView(@LayoutRes int layoutResID)</code>中解析并创建视图树。在PhoneWindow中创建DecorView实例，利用LayoutInflater解析布局文件。主要流程：</p>
<ul>
<li>生成<code>DecorView</code>（继承FrameLayout）实例。</li>
<li>解析<code>screen_*.xml</code>布局（包含ID为content的FrameLayout，对应引用为<code>mContentParent</code>）并填充到<code>DecorView</code>中。</li>
<li>解析App自定义的布局文件并填充到<code>mContentParent</code>引用的FrameLayout中。</li>
</ul>
<p>简略时序图：</p>
<p><img src="/images/android-set-content-view-sq.svg"></p>
<p>最终生成的视图树结构：</p>
<p><img src="/images/android-activity-ui-structure.svg"></p>
<p><code>screen_*.xml</code>文件位于<code>base/core/res/res/layout</code>目录下，<code>screen_titil.xml</code>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Popout bar for action modes --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_mode_bar_stub&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">&quot;@+id/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">&quot;@layout/action_mode_bar&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">&quot;?attr/actionBarTheme&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;?android:attr/windowTitleSize&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">&quot;?android:attr/windowTitleBackgroundStyle&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:id</span>=<span class="string">&quot;@android:id/title&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">style</span>=<span class="string">&quot;?android:attr/windowTitleStyle&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@null&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:fadingEdge</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此处填充App自定义的内容布局 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">android:id</span>=<span class="string">&quot;@android:id/content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dip&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:foregroundGravity</span>=<span class="string">&quot;fill_horizontal|top&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:foreground</span>=<span class="string">&quot;?android:attr/windowContentOverlay&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><h3 id="Activity-setContentView"><a href="#Activity-setContentView" class="headerlink" title="Activity.setContentView()"></a><code>Activity.setContentView()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mWindow此处其实现为PhoneWindow</span></span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    <span class="comment">// 初始化ActionBar</span></span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PhoneWindow-setContentView"><a href="#PhoneWindow-setContentView" class="headerlink" title="PhoneWindow.setContentView()"></a><code>PhoneWindow.setContentView()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Decor和Activity内容视图的Parent</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 该方法的工作：</span></span><br><span class="line">        <span class="comment">// 1.生成DecorView实例： mDecor = generateDecor(-1) -&gt; new DecorView(context...);</span></span><br><span class="line">        <span class="comment">// 2.填充App内容的父布局：mContentParent = generateLayout(mDecor);</span></span><br><span class="line">        installDecor();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通情况，解析App自定义布局文件并生成视图，添加到mContentParent中</span></span><br><span class="line">    mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PhoneWindow-generateLayout"><a href="#PhoneWindow-generateLayout" class="headerlink" title="PhoneWindow.generateLayout()"></a><code>PhoneWindow.generateLayout()</code></h3><p>填充App内容的父布局，一般包括标题区域和内容区域，内容区域的视图ID固定为<code>ID_ANDROID_CONTENT = &quot;com.android.internal.R.id.content&quot;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 填充布局，工作如下：</span></span><br><span class="line">    <span class="comment">// 首先，利用LayoutInflater.inflate()方法解析布局文件，如`screen_*.xml`文件</span></span><br><span class="line">    <span class="comment">// 其次，将解析后的视图添加到DecorView中，DecorView作为整个新视图的根节点</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">    <span class="comment">// 绑定Activity内容视图的父布局, 一般为FrameLayout, ID固定</span></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LayoutInflater-inflate"><a href="#LayoutInflater-inflate" class="headerlink" title="LayoutInflater.inflate()"></a><code>LayoutInflater.inflate()</code></h3><p>解析内容布局文件生成视图树并添加到内容视图容器(<code>ID_ANDROID_CONTENT</code>)里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Context inflaterContext = mContext;</span><br><span class="line">    <span class="keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">    <span class="comment">// 资源根布局。这里的root是mContentParent引用, 指向ID为ID_ANDROID_CONTENT的ViewGroup</span></span><br><span class="line">    <span class="keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line">    <span class="comment">// 递归解析</span></span><br><span class="line">     rInflateChildren(parser, temp, attrs, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 添加内容视图树到mContentParent视图里</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; attachToRoot) &#123;</span><br><span class="line">        root.addView(temp, params);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="绘制视图"><a href="#绘制视图" class="headerlink" title="绘制视图"></a>绘制视图</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>视图绘制的入口为<code>ActivityThread.handleResumeActivity()</code>，该方法主要工作为：</p>
<ul>
<li>添加Window。调用方法中的<code>WindowManager.addView()</code>创建<code>ViewRootImpl</code>，与<code>DecorView</code>绑定。在<code>ViewRootImpl</code>中创建<code>Window</code>，并将该<code>Window</code>通过<code>Session</code>添加到<code>WMS</code>里，其代表为<code>WindowState</code>。在此过程<code>WindowState</code>会创建与<code>SurfaceFlinger</code>的连接<code>SurfaceSession</code>（Java层）和<code>SurfaceComposerClient</code>（Native层），只有与SurfaceFlinger连接后绘制的视图才能渲染呈现出来。</li>
<li>执行具体绘制操作。与WindowManagerService建立连接的前、后都会去执行绘制操作，连接前调用<code>ViewRootImpl.requestLayout()</code>，连接后调用<code>Activity.makeVisible()</code>（该方法是否会被调用？<strong>TODO</strong>），但无论哪个绘制入口，最终都会调用<code>ViewRootImpl.scheduleTraversals()</code>。</li>
</ul>
<blockquote>
<p>本节只讨论添加Window的操作，不讨论具体View绘制以及与Surface、SurfaceFlinger相关的流程，具体绘制流程见我的相关博客。</p>
<p>本节WMS与Window逻辑撰写不够清晰，如待以后更新 <strong>TODO</strong>。</p>
</blockquote>
<p>时序图：</p>
<p><img src="/images/android-activity-perform-resume.svg" alt="activity-perform-resume"></p>
<h2 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h2><p>这块涉及到的类比较多和繁杂，有必要单独详细说明一下。类图如下：</p>
<p><img src="/images/android-ui-class-uml.svg"></p>
<p>App端：</p>
<ul>
<li>Window。用户与App交互的顶级视图，可理解为具体视图View的容器，与底层的Surface一一对应，多个Window或多个Surface最终形成一帧图像呈现给用户。</li>
<li>PhoneWindow，继承Window。Activity持有窗口实例，持有成员：DecorView、状态栏各属性、主题、导航和标题等属性等。</li>
<li>ViewRootImpl，继承ViewParent。App端视图树抽象的根，但不是实际的View，通过Session与服务端通信，并管理视图树的具体绘制。</li>
<li>DecorView，继承FramLayout。窗口实际视图树的根View，持有ViewRootImpl作为父。</li>
<li>WindowManager，继承ViewManger接口。包含View的添加、更新和移除等操作方法。</li>
<li>WindowManagerImpl，实现WM。WMImp持有WMGlobal单例，WMImpl在生成实例时会生成全局（应用）唯一的WMGlobal。</li>
<li>WindowManagerGlobal，单例。提供与WMS低级别通信的方法，与Context无关，持有成员：DecorView集合、ViewRootImpl集合以及布局参数集合等。</li>
</ul>
<p>Service端：</p>
<ul>
<li>ViewRootImpl.W，实现IWindow。客户端与服务端通信时代表客户端的窗口，持有成员：ViewRootImpl和Session。这个与App端的Window不是同一个东西，是它的代表。</li>
<li>Session，实现IWindowSession。用于App端与服务端间的通信，每个App端都有一个Session与服务端连接。</li>
<li>WMS，实现IWindowManager。主要用于管理App端的窗口：为窗口分配Surface，创建与SurfaceFlinger的连接，掌管Surface的显示顺序（Z序）以及大小尺寸、控制窗口动画，另外还管理输入事件的通道。</li>
<li>WindowState，实现WMPolicy.WindowState。用于管理IWindow，持有成员：IWindow、Session等。</li>
</ul>
<h2 id="关键方法-1"><a href="#关键方法-1" class="headerlink" title="关键方法"></a>关键方法</h2><h3 id="ActivityThread-handleResumeActivity"><a href="#ActivityThread-handleResumeActivity" class="headerlink" title="ActivityThread.handleResumeActivity()"></a>ActivityThread.handleResumeActivity()</h3><p>主要工作：执行Resume并最终执行Activity.onResume()方法、添加Window、执行绘制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该方法内部会依次调用Activity的onStart()或onRestart()、onResume()等方法</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, ...);</span><br><span class="line">    <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">        <span class="comment">// 添加view绑定到Window中, 内部调用：</span></span><br><span class="line">        <span class="comment">// -&gt; WindowManagerImpl.addView() -&gt; WindowManagerGlobal.addView()</span></span><br><span class="line">        a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">        wm.addView(decor, l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行绘制</span></span><br><span class="line">    <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">        <span class="comment">// 内部调用:</span></span><br><span class="line">    	<span class="comment">// DecorView.setVisibility(View.VISIBLE) -&gt; View.invalidate(true)...</span></span><br><span class="line">        r.activity.makeVisible();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WindowManagerGlobal-addView"><a href="#WindowManagerGlobal-addView" class="headerlink" title="WindowManagerGlobal.addView()"></a>WindowManagerGlobal.addView()</h3><p>创建ViewRootImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android.view.WindowManagerGlobal</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建ViewRootImpl实例，被WMG持有</span></span><br><span class="line">    <span class="comment">// DecorView也被WMG持有</span></span><br><span class="line">    ViewRootImpl  root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line">    mViews.add(view);</span><br><span class="line">    mRoots.add(root);</span><br><span class="line">    mParams.add(wparams);</span><br><span class="line">    root.setView(view, wparams, panelParentView);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ViewRootImpl-setView"><a href="#ViewRootImpl-setView" class="headerlink" title="ViewRootImpl.setView()"></a>ViewRootImpl.setView()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在添加到WMS之前先执行一次绘制</span></span><br><span class="line">    requestLayout();</span><br><span class="line">    <span class="comment">// 通过Session添加window到WMS IPC, </span></span><br><span class="line">    <span class="comment">// Session是ViewRootImpl在构造方法里从WMS获取的</span></span><br><span class="line">    res = mWindowSession.addToDisplay(mWindow, mSeq, ...);</span><br><span class="line">    <span class="comment">// 设置DecorView的parent为ViewRootImpl</span></span><br><span class="line">    view.assignParent(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WindowManagerService-addWindow"><a href="#WindowManagerService-addWindow" class="headerlink" title="WindowManagerService.addWindow()"></a>WindowManagerService.addWindow()</h3><p>创建WindowState、SurfaceSession等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,...)</span></span>&#123;</span><br><span class="line">    <span class="comment">// WindowState代表WM里的Window</span></span><br><span class="line">    <span class="keyword">final</span> WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, ...);</span><br><span class="line">    <span class="comment">// 一个window只能有一个输入通道，发送输入事件到window</span></span><br><span class="line">    <span class="keyword">if</span>  (openInputChannels) &#123;</span><br><span class="line">        win.openInputChannel(outInputChannel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// session 绑定packagename，生成SurfaceSession实例</span></span><br><span class="line">    win.attach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangliangnbu.github.io/2021/12/17/android-activity-start-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="章亮">
      <meta itemprop="description" content="Developer For Android">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒的码流">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/17/android-activity-start-guide/" class="post-title-link" itemprop="url">Andoird 10 Activity启动流程概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-17 15:49:34" itemprop="dateCreated datePublished" datetime="2021-12-17T15:49:34+08:00">2021-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-20 15:38:57" itemprop="dateModified" datetime="2021-12-20T15:38:57+08:00">2021-12-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Android系统开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于Android 10 源码 。Activity启动分为两种：</p>
<ul>
<li>普通Activity启动：APP已经启动，一般在APP内从一个Activity启动另一个Activity。</li>
<li>根Activity启动：也称为APP冷启动，App还没有启动，一般从Launcher界面启动。</li>
</ul>
<p>两者主流程基本一致，区别在于根Activity启动流程还包含启动APP进程和实例化Application的流程。</p>
<h1 id="普通Activity启动流程"><a href="#普通Activity启动流程" class="headerlink" title="普通Activity启动流程"></a>普通Activity启动流程</h1><h2 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h2><p>分析方法<code>Activity.startActivity()</code> 到<code>Activity.onCreate()</code>的流程，流程图如下。</p>
<p><img src="/images/aosp10-activity-start-create.svg" alt="aosp10-activity-start-create"></p>
<p>流程说明：</p>
<ol>
<li>客户端发起启动Activity请求。客户端里的Activity通过<code>Instrumentation.execStartActivity()</code>请求服务端的ATMS启动Activity。</li>
<li>服务端完成Intent解析和数据、权限、状态等检查的准备工作。ATMS通过ActivityStarter、ActivityStack、ActivityStackSupervisor等完成Intent解析、检查等准备工作，并将数据传递给客户端的ApplicationThread，请求后者完成剩余启动工作。</li>
<li>客户端完成Activity的创建、数据绑定、onCreate回调等工作。ApplicationThread通过ActivityThread将数据传到其主线程的Handler中进行处理，完成Activity的创建、数据绑定和onCreate回调等工作。</li>
</ol>
<h2 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h2><h3 id="Instrumentation-execStartActivity"><a href="#Instrumentation-execStartActivity" class="headerlink" title="Instrumentation.execStartActivity()"></a><code>Instrumentation.execStartActivity()</code></h3><p>请求服务端的ATMS启动Activity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who, IBinder contextThread, IBinder token ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// IPC：调用 ActivityTaskManagerService</span></span><br><span class="line">    <span class="keyword">int</span> result = ActivityTaskManager.getService().startActivity(</span><br><span class="line">        whoThread, <span class="comment">// 发起方 IApplicationThread</span></span><br><span class="line">        who.getBasePackageName(), <span class="comment">// 发起方 package name</span></span><br><span class="line">        intent, <span class="comment">// 目标</span></span><br><span class="line">        <span class="comment">// Data MIME 类型，没有数据时为空</span></span><br><span class="line">        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">        token,  <span class="comment">// 发起方 IBinder</span></span><br><span class="line">        target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>, <span class="comment">// mEmbeddedID 作用？TODO</span></span><br><span class="line">        requestCode, </span><br><span class="line">        <span class="number">0</span>, <span class="comment">// startFlag</span></span><br><span class="line">        <span class="keyword">null</span>, <span class="comment">// ProfilerInfo profilerInfo 作用？TODO</span></span><br><span class="line">        options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ActivityStarter-startActivityMayWait"><a href="#ActivityStarter-startActivityMayWait" class="headerlink" title="ActivityStarter.startActivityMayWait()"></a><code>ActivityStarter.startActivityMayWait()</code></h3><p>解析Intent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="keyword">int</span> callingUid ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析Intent获取ResolveInfo，核心是获取其成员ActivityInfo。</span></span><br><span class="line">    <span class="comment">// 最终调用 PMS#queryIntentActivitiesInternal()：</span></span><br><span class="line">    <span class="comment">// 1. 通过Intent中ComponentName获取安装apk或扫描时解析过并保存的ActivityInfo;</span></span><br><span class="line">    <span class="comment">// 2. 设置ActivityInfo的metaData和applicationInfo</span></span><br><span class="line">    <span class="comment">// 上面的ActivityInfo作为新建的ResolveInfo成员，跟随后者一起被返回</span></span><br><span class="line">    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId...);</span><br><span class="line">    <span class="comment">// 普通情况仅仅将rInfo的数据设置到intent中</span></span><br><span class="line">    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ActivityStarter-startActivity"><a href="#ActivityStarter-startActivity" class="headerlink" title="ActivityStarter.startActivity()"></a><code>ActivityStarter.startActivity()</code></h3><p>检查权限等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, Intent intent ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查启动方的权限，系统方或同一个APP等则可授权</span></span><br><span class="line">    <span class="keyword">boolean</span> abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho ...);</span><br><span class="line">    abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid ...);</span><br><span class="line">    abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,callingPackage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ActivityStackSupervisor-realStartActivityLocked"><a href="#ActivityStackSupervisor-realStartActivityLocked" class="headerlink" title="ActivityStackSupervisor.realStartActivityLocked()"></a><code>ActivityStackSupervisor.realStartActivityLocked()</code></h3><p>生成事务，为IPC到客户端创建Activity准备</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, WindowProcessController proc...)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 准备工作：锁定屏幕、开始计时、绑定进程、确保可见和配置...</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 添加启动Activity事务项</span></span><br><span class="line">    <span class="keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(proc.getThread(), r.appToken);</span><br><span class="line">    <span class="keyword">final</span> DisplayContent dc = r.getDisplay().mDisplayContent;</span><br><span class="line">	clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="keyword">new</span> Intent(r.intent), ...));</span><br><span class="line">    <span class="comment">// 添加使Activity处于resume事务项</span></span><br><span class="line">    <span class="comment">// 在TransactionExecutor.execute()里会依次处理callback、LifecycleState</span></span><br><span class="line">    <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class="line">    <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">        lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">    &#125;</span><br><span class="line">    clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line">    <span class="comment">// Schedule transaction.</span></span><br><span class="line">	<span class="comment">// ActivityTaskManagerService</span></span><br><span class="line">    mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ActivityThread-performLaunchActivity"><a href="#ActivityThread-performLaunchActivity" class="headerlink" title="ActivityThread.performLaunchActivity()"></a><code>ActivityThread.performLaunchActivity()</code></h3><p>创建Activity，绑定数据等，执行<code>Activity.onCreate()</code>回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// activity 准备创建需要的相关数据，创建</span></span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">    <span class="comment">// 反射创建Activity对象，还不能交互</span></span><br><span class="line">    Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);</span><br><span class="line">    <span class="comment">// 如果已经存在，直接返回</span></span><br><span class="line">    Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">    <span class="comment">// 绑定Activity与其他数据：绑定Context，创建PhoneWindow，绑定线程、Token、Application等</span></span><br><span class="line">    activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token...);</span><br><span class="line">    <span class="comment">// 触发onCreate调用</span></span><br><span class="line">    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="根Activity启动流程"><a href="#根Activity启动流程" class="headerlink" title="根Activity启动流程"></a>根Activity启动流程</h1><h2 id="流程概述-1"><a href="#流程概述-1" class="headerlink" title="流程概述"></a>流程概述</h2><p>一般也称为APP冷启动流程，分析从Launcher界面点击APP图标到APP显示完成的流程。相比从普通Activity启动流程，App的冷启动流程多了两个步骤：创建进程，绑定并创建Application对象。</p>
<p><img src="/images/aosp10-app-start-cold.svg" alt="aosp10_app_start_cold"></p>
<p>图中虚线部分是创建APP进程和启动Application的流程。</p>
<p>普通Activity启动流程走到<code>ActivityStackSupervisor.startSpecificActivityLocked()</code>时，有一个进程相关的判断：如果应用进程存在则去启动Activity，否则去创建进程。冷启动时，App进程还不存在，因此需要去创建进程，其入口便是这里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Is this activity&#x27;s application already running?</span></span><br><span class="line">    <span class="keyword">final</span> WindowProcessController wpc =</span><br><span class="line">            mService.getProcessController(r.processName, r.info.applicationInfo.uid);</span><br><span class="line">    <span class="keyword">boolean</span> knownToBeDead = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// APP进程存在时，启动Activity</span></span><br><span class="line">    <span class="keyword">if</span> (wpc != <span class="keyword">null</span> &amp;&amp; wpc.hasThread()) &#123;</span><br><span class="line">        <span class="comment">// 启动 Activity</span></span><br><span class="line">        realStartActivityLocked(r, wpc, andResume, checkConfig);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// APP进程不存在时，创建进程</span></span><br><span class="line">    <span class="comment">// Message 里设置了一个回调，即 ActivityManagerInternal.startProcess</span></span><br><span class="line">    <span class="keyword">final</span> Message msg = PooledLambda.obtainMessage(</span><br><span class="line">            ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName,</span><br><span class="line">            r.info.applicationInfo, knownToBeDead, <span class="string">&quot;activity&quot;</span>, r.intent.getComponent());</span><br><span class="line">		<span class="comment">// 发送消息到&quot;android.display&quot;线程处理</span></span><br><span class="line">    mService.mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>APP的冷启动过程主涉及到四个进程：Launcher进程（启动APP的进程）、SystemServer进程、APP进程、Zygote进程；三个重要工作：启动进程、启动Application、启动Activity。</p>
<p>整个流程简述为：</p>
<ul>
<li>Launcher进程请求SystemServer进程创建Activity</li>
<li>SystemServer进程解析Intent等，并检查目标APP进程是否存在，不存在则去创建进程。</li>
<li>SystemServer进程通过Socket方式请求Zygote进程创建APP进程，返回进程号等信息。</li>
<li>App进程入口为<code>ActivityThread.main()</code>方法，执行此方法，初始化进程并请求SystemServer绑定APP进程。绑定进程的工作包括，一，通知APP进程去启动Application；二，通知APP进程去启动Activity。</li>
</ul>
<aside> 💡 这里说的启动包含创建实例以及执行回调方法等操作。

<h2 id="方法说明-1"><a href="#方法说明-1" class="headerlink" title="方法说明"></a>方法说明</h2><p>与普通Activity启动流程重复的方法不再进行说明</p>
<h3 id="ProcessList-startProcessLocked"><a href="#ProcessList-startProcessLocked" class="headerlink" title="ProcessList.startProcessLocked()"></a><code>ProcessList.startProcessLocked()</code></h3><p>指定进程执行入口为<code>android.app.ActivityThread.main()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置进程启动相关参数</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, HostingRecord hostingRecord ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 进程执行入口</span></span><br><span class="line">    <span class="keyword">final</span> String entryPoint = <span class="string">&quot;android.app.ActivityThread&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> startProcessLocked(hostingRecord, entryPoint, app, uid, gids,</span><br><span class="line">                              runtimeFlags, mountExternal, seInfo, requiredAbi, </span><br><span class="line">                              instructionSet, invokeWith,startTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZygoteProcess-startViaZygote"><a href="#ZygoteProcess-startViaZygote" class="headerlink" title="ZygoteProcess.startViaZygote()"></a><code>ZygoteProcess.startViaZygote()</code></h3><p>设置zygote启动进程的参数</p>
<h3 id="ZygoteProcess-attemptZygoteSendArgsAndGetResult"><a href="#ZygoteProcess-attemptZygoteSendArgsAndGetResult" class="headerlink" title="ZygoteProcess.attemptZygoteSendArgsAndGetResult()"></a><code>ZygoteProcess.attemptZygoteSendArgsAndGetResult()</code></h3><p>发送数据以启动进程，获取进程启动后的进程号等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送数据以启动进程，获取进程启动后的进程号等</span></span><br><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">attemptZygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ZygoteState zygoteState, String msgStr)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;</span><br><span class="line">    <span class="keyword">final</span> DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;</span><br><span class="line">	<span class="comment">// 发消息给Zygote进程，各种参数</span></span><br><span class="line">    zygoteWriter.write(msgStr);</span><br><span class="line">    zygoteWriter.flush();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 启动进程中...最终会执行ActivityThread.main方法</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 获取启动进程后结果，进程号等</span></span><br><span class="line">    Process.ProcessStartResult result = <span class="keyword">new</span> Process.ProcessStartResult();</span><br><span class="line">    result.pid = zygoteInputStream.readInt();</span><br><span class="line">    result.usingWrapper = zygoteInputStream.readBoolean();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ActivityThread-main"><a href="#ActivityThread-main" class="headerlink" title="ActivityThread.main()"></a><code>ActivityThread.main()</code></h3><p>进程入口方法，初始化主线程，绑定进程，启动应用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 主线程Looper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">	<span class="comment">// 当前启动中进程的标识符，从ZygoteProcess相关方法传入</span></span><br><span class="line">    <span class="keyword">long</span> startSeq = <span class="number">0</span>;</span><br><span class="line">	ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">	<span class="comment">// 绑定进程，false 表示非系统进程，会调用AMS.attachApplication()</span></span><br><span class="line">    thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line">	<span class="comment">// 主线程绑定的Handler</span></span><br><span class="line">    sMainThreadHandler = thread.getHandler();</span><br><span class="line">	<span class="comment">// 防止线程结束，等待如Application.onCreate()、Activity.onCreate()等周期回调方法</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ActivityManagerService-attachApplicationLocked"><a href="#ActivityManagerService-attachApplicationLocked" class="headerlink" title="ActivityManagerService.attachApplicationLocked()"></a><code>ActivityManagerService.attachApplicationLocked()</code></h3><p> 启动Application、启动Activity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取并设置Application Record，启动Application，启动Activity等</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(<span class="meta">@NonNull</span> IApplicationThread thread,<span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// zygote启动进程返回结果后，pid会被保存到mPidsSelfLocked中</span></span><br><span class="line">    <span class="comment">// 见 ProcessList.startProcessLocked 方法中执行的</span></span><br><span class="line">    <span class="comment">// ProcessList.handleProcessStartedLocked，启动进程后更新状态</span></span><br><span class="line">    <span class="comment">// 有概率发生当前方法先于handleProcessStartedLocked执行，则app=null</span></span><br><span class="line">    ProcessRecord app = mPidsSelfLocked.get(pid);</span><br><span class="line">    <span class="comment">// 设置app参数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// ipc 启动Application, 最终在APP进程调用ActivityThread.handleBindApplication()</span></span><br><span class="line">    thread.bindApplication(processName, appInfo, providers, ...);</span><br><span class="line">    <span class="comment">// 去启动Activity。最终调用ActivityStackSupervisor.realStartActivityLocked()</span></span><br><span class="line">    didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ActivityThread-handleBindApplication"><a href="#ActivityThread-handleBindApplication" class="headerlink" title="ActivityThread.handleBindApplication()"></a><code>ActivityThread.handleBindApplication()</code></h3><p>设置APP数据，创建Application实例，调用<code>Application.onCreate()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置APP名称</span></span><br><span class="line">    Process.setArgV0(data.processName);</span><br><span class="line">    android.ddm.DdmHandleAppName.setAppName(data.processName, UserHandle.myUserId());</span><br><span class="line">    VMRuntime.setProcessPackageName(data.appInfo.packageName);</span><br><span class="line">    <span class="comment">// 设置应用缓存数据目录</span></span><br><span class="line">    VMRuntime.setProcessDataDirectory(data.appInfo.dataDir);</span><br><span class="line">    <span class="comment">// 设置时区和本地化</span></span><br><span class="line">    TimeZone.setDefault(<span class="keyword">null</span>);</span><br><span class="line">    LocaleList.setDefault(data.config.getLocales());</span><br><span class="line">    <span class="comment">// 创建应用包的数据</span></span><br><span class="line">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line">    <span class="keyword">if</span> (agent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleAttachAgent(agent, data.info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置屏幕分辨率(用于兼容)、时间格式、网络代理</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 判断并获取或创建 Instrumentation，之后会用来创建Application</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建Application、重写资源相关的R常量</span></span><br><span class="line">    Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">	mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">	<span class="comment">// 执行Application.onCreate回调</span></span><br><span class="line">	mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">	<span class="comment">// 加载字体资源</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/core</span><br><span class="line">    com.android.server.wm.ActivityTaskManagerService </span><br><span class="line">    com.android.server.wm.ActivityStarter</span><br><span class="line">    com.android.server.wm.RootActivityContainer</span><br><span class="line">    com.android.server.wm.ActivityStack</span><br><span class="line">    com.android.server.wm.ActivityStackSupervisor</span><br><span class="line">    com.android.server.wm.ClientLifecycleManager</span><br><span class="line">    com.android.server.am.ActivityManagerService</span><br><span class="line">    com.android.server.am.ActivityManagerService.LocalService</span><br><span class="line">    com.android.server.am.ProcessList</span><br><span class="line">frameworks/base/core</span><br><span class="line">    android.app.Activity</span><br><span class="line">    android.app.Instrumentation</span><br><span class="line">    android.app.ActivityThread</span><br><span class="line">    android.app.ActivityThread.ApplicationThread</span><br><span class="line">    android.app.servertransaction.LaunchActivityItem</span><br><span class="line">    android.app.servertransaction.TransactionExecutor</span><br><span class="line">    android.app.servertransaction.ClientTransaction</span><br><span class="line">    android.os.Process</span><br><span class="line">    android.os.ZygoteProcess</span><br><span class="line">    android.app.LoadedApk</span><br><span class="line">    android.app.AppComponentFactory</span><br><span class="line">    android.app.Application</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://aospxref.com/android-10.0.0_r47/">Android 10 源码</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangliangnbu.github.io/2021/12/15/android-aosp-compile-flashing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="章亮">
      <meta itemprop="description" content="Developer For Android">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒的码流">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/15/android-aosp-compile-flashing/" class="post-title-link" itemprop="url">Android10系统编译和烧录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-15 15:10:20" itemprop="dateCreated datePublished" datetime="2021-12-15T15:10:20+08:00">2021-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 15:51:08" itemprop="dateModified" datetime="2021-12-17T15:51:08+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Android系统开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>基于Ubuntu 20.04编译AOSP里的Android 10系统，并烧录进Pixel 2实机设备里。</p>
<blockquote>
<p>烧录指将编译后的系统文件刷入实机或模拟器中</p>
</blockquote>
<p>也适用Ubuntu18.4，不一致的地方会做说明，主要是python版本有差异。</p>
<p>应该说<a target="_blank" rel="noopener" href="https://developer.android.google.cn/">AOSP官网</a>对整个流程都有描述，但有些地方可能说得不够清楚明白，为避免不常编译系统的开发者少走弯路，故有此总结。另外需要说明的是，优先看官网文档，官网有不清楚地方再看其他资料比如本文。</p>
<p>AOSP官网有两个，国际版本和国内版本，内容一致，但国内版本速度较快些。</p>
<ul>
<li>国际版本：<a target="_blank" rel="noopener" href="https://source.android.com/">https://source.android.com</a></li>
<li>国内版本：<a target="_blank" rel="noopener" href="https://source.android.google.cn/">https://source.android.google.cn</a></li>
</ul>
<h1 id="搭建编译环境"><a href="#搭建编译环境" class="headerlink" title="搭建编译环境"></a>搭建编译环境</h1><p><strong>硬件环境说明</strong></p>
<p><a target="_blank" rel="noopener" href="https://source.android.google.cn/setup/build/requirements">官网构建环境章节</a>上说了编译Android 10必须保证机器的内存在16G以上，实践过程中发现低于16G内存会报各种错误。网上有一些方法可以在低于16G内存的机器上通过编译，尝试了其中的一些，依旧不能完成编译，故最好保证机器内存在16G以上，内存越大编译速度越快，血的教训，注意。</p>
<p><strong>开发平台版本说明</strong></p>
<ul>
<li>Ubuntu 20.04</li>
<li>Python 3.6+</li>
<li>Android 10 系统信息：QP1A.190711.019，android-10.0.0_r1    Android10，Pixel 3a XL, Pixel 3a, Pixel 3 XL, Pixel 3, Pixel 2 XL, Pixel 2, Pixel XL, Pixel    2019-09-05</li>
<li>其他</li>
</ul>
<aside> 💡 Ubuntu 20.4 need Python 3.6+, Ubuntu 18.4 need Python 2.7+

<p><strong>设置软件环境</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 libncurses5-dev lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig</span><br></pre></td></tr></table></figure>

<p><strong>配置Git</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>检查Python</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python --version</span><br><span class="line"><span class="comment"># if no python, then set a link</span></span><br><span class="line"><span class="comment"># use &#x27;whereis python&#x27; to find where python locate.</span></span><br><span class="line">sudo ln -s /usr/bin/python3 /usr/bin/python</span><br></pre></td></tr></table></figure>

<p><strong>安装Repo工具</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/bin</span><br><span class="line">PATH=~/bin:<span class="variable">$PATH</span></span><br><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure>

<p><strong>将REPO_URL改清华的源</strong></p>
<p>我使用的是清华源，使用其他源也可以</p>
<p>方法一：配置环境变量（推荐）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bashrc</span><br><span class="line"><span class="comment"># export REPO_URL=&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&#x27;</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>方法二：直接更改repo文件配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到repo</span></span><br><span class="line">whereis repo</span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line">sudo vim /usr/bin/repo</span><br><span class="line"><span class="comment"># REPO_URL = &#x27;https://gerrit.googlesource.com/git-repo&#x27;</span></span><br><span class="line"><span class="comment"># 改为：</span></span><br><span class="line"><span class="comment"># REPO_URL = &#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="下载系统源代码"><a href="#下载系统源代码" class="headerlink" title="下载系统源代码"></a>下载系统源代码</h1><p>Android 10源代码也有很多小的版本，我们这里只下载最初的版本<code>android-10.0.0_r1</code>，官网可查看版本，见<a target="_blank" rel="noopener" href="https://source.android.google.cn/setup/start/build-numbers">代号、标记和 Build 号</a>，其中我们需要的是标记（Tags）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir aosp10</span><br><span class="line"><span class="built_in">cd</span> aosp10</span><br><span class="line"><span class="comment"># 注意这里的连接要改为清华镜像的 -b后面为分支版本，如可改为 android-10.0.0_r47 </span></span><br><span class="line"><span class="comment"># repo init -u https://android.googlesource.com/platform/manifest</span></span><br><span class="line"><span class="comment"># repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-9.0.0_r1 --depth=1</span></span><br><span class="line">repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-10.0.0_r1 --depth=1</span><br><span class="line"><span class="comment"># 开始下载 j后面的数字是线程数，推荐写4</span></span><br><span class="line">repo sync -c -j4</span><br></pre></td></tr></table></figure>

<aside> 💡 另外一种下载源码的方法是 先用wget命令下载，然后解压、同步。

<h1 id="编译源代码"><a href="#编译源代码" class="headerlink" title="编译源代码"></a>编译源代码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">$ lunch aosp_walleye-userdebug</span><br><span class="line">$ m</span><br><span class="line">...等待编译完成，没有报error就表示编译通过</span><br><span class="line">...一般需要几个小时到十几个小时不等，我使用32G内存时，大约需要3~4个小时</span><br></pre></td></tr></table></figure>

<p>其中，<code>lunch</code>后的参数<code>aosp_walleye-userdebug</code>为Pixel 2手机的设备Build编号，因为我后面会将编译后的系统刷入谷歌pixel 2手机中，故选择此Build编号。</p>
<p>设备Build编号选择说明见官网<a target="_blank" rel="noopener" href="https://source.android.google.cn/setup/build/running#selecting-device-build">设备Build编号</a>。</p>
<h1 id="实机烧录"><a href="#实机烧录" class="headerlink" title="实机烧录"></a>实机烧录</h1><p><strong>下载并安装硬件驱动文件</strong></p>
<p>硬件烧录时需要，如果不烧录到硬件则不需要下载。</p>
<p>根据代号<code>qp1a.190711.019</code>查找Google和高通相关驱动，地址：<a target="_blank" rel="noopener" href="https://developers.google.cn/android/drivers#walleyeqp1a.190711.019">Pixel 2 binaries for Android 10.0.0 (QP1A.190711.019)</a></p>
<p>下载完后解压放在aosp源码根目录，并安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh extract-google_devices-walleye.sh</span><br><span class="line">sh extract-qcom-walleye.sh</span><br><span class="line"><span class="comment"># 看完license输入 I ACCEPT 安装完成, 此时ls会看到vendor文件夹</span></span><br></pre></td></tr></table></figure>

<p><strong>安装刷机工具</strong></p>
<p>安装和配置ADB、FASTBOOT工具。</p>
<p>安装：有两种方法安装工具，从SDK配置或直接命令行安装下载</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install android-tools-adb</span><br><span class="line">$ sudo apt-get install android-tools-fastboot</span><br></pre></td></tr></table></figure>

<p>配置：对于Ubuntu系统需要进行两项配置，一是添加当前用户到 plugdev 组中，二是配置udev 规则，详情请见<a target="_blank" rel="noopener" href="https://developer.android.com/studio/run/device">官网-在硬件设备上运行应用</a></p>
<aside> 💡 注意使用数据线时，需要有通信能力的，有的usb数据线仅仅只有充电功能，本人亲身经历过！

<p><strong>刷机</strong></p>
<p>前提是手机已经解锁，我使用的Pixel 2手机已经解锁，使用以下命令进行烧录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在lunch环境里</span></span><br><span class="line">$ <span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">$ lunch aosp_walleye-userdebug</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入BootLoader</span></span><br><span class="line">$ adb reboot bootloader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 烧录</span></span><br><span class="line">$ fastboot flashall -w</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://source.android.google.cn/setup/start?hl=zh-cn">官网-AOSP编译</a>：起始页</li>
<li><a target="_blank" rel="noopener" href="https://source.android.google.cn/setup/start/build-numbers">官网-代号、标记和 Build 号</a>：根据标记下载源码版本，根据代号下载实机设备驱动。</li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/studio/run/device">官网-在硬件设备上运行应用</a>：设置Linux系统以检测USB设备</li>
<li><a target="_blank" rel="noopener" href="https://source.android.com/setup/build/running?hl=zh-cn#flashing-a-device">官网-刷写设备</a></li>
<li><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/">清华源-Android 镜像使用帮助</a>：清华源下载AOSP代码</li>
<li><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/git-repo/">清华源-Git Repo 镜像使用帮助</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ciml/p/13714036.html">三方博客-编译AOSP并刷入Pixel设备</a>：参考烧录章节</li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904104368537613">三方博客-Android 9.0编译</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/mvp_Dawn/article/details/107624203">三方博客-ubuntu20.4编译AOSP安卓源码（AndroidP android-9.0.0_r9）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.hanschen.site/2019/09/12/aosp_compile_and_flash/">三方博客-AOSP 编译和烧写（实机烧录）</a></li>
<li><a target="_blank" rel="noopener" href="https://debugtalk.com/post/android-development-environment-adb-and-fastboot/">三方博客-Android开发环境配置0：adb和fastboot</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangliangnbu.github.io/2021/12/09/android-jni-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="章亮">
      <meta itemprop="description" content="Developer For Android">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒的码流">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/09/android-jni-guide/" class="post-title-link" itemprop="url">JNI开发概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-09 17:14:28" itemprop="dateCreated datePublished" datetime="2021-12-09T17:14:28+08:00">2021-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-17 12:13:59" itemprop="dateModified" datetime="2021-12-17T12:13:59+08:00">2021-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Android开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>JNI，即Java本地接口（Java Native Interface），允许Java代码与C/C++等本地语言编写的代码进行交互操作。</p>
<p>JNI提供的接口声明位于：<code>&lt;JDK_HOME&gt;/include/jni.h</code>中</p>
<blockquote>
<p>注意：JNI是Java的特性而非Android独有特性，只因为Android使用了Java语言，因此可以利用JNI的功能。</p>
</blockquote>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><strong>Java虚拟机</strong>利用<strong>函数原型</strong>将Java声明的本地方法与运行库中的C函数通过函数映射表对应起来，这样Java代码就能与C/C++代码交互。</p>
<blockquote>
<p><strong>函数原型</strong>（英语：<strong>Function prototype</strong>）或<strong>函数接口</strong>（英语：<strong>Function interface</strong>）是用于指定函数的名称和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%AD%BE%E5%90%8D">类型签名</a>（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%83%E6%95%B0">元数</a>，参数的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E9%A1%9E%E5%9E%8B">数据类型</a>和返回值类型）的一种省略了函数体的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F">函数</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%A3%B0%E6%98%8E&action=edit&redlink=1">声明</a>。</p>
</blockquote>
<blockquote>
<p>思考一：Java虚拟机作为桥梁。Java代码和C/C++本地代码运行环境不一样，因此不能直接交互，而Java代码的容器Java虚拟机是C/C++代码编写的，因此可以使用Java虚拟机作为桥梁将Java代码和C/C++本地代码联系起来。</p>
<p>思考二：为什么用函数原型？Java方法和C/C++函数是不一样的，但它们可以在函数原型上变为一致，都有名称和签名，因此可以使用函数原型建立映射关系。</p>
</blockquote>
<h2 id="Java代码与JNI本地函数的交互"><a href="#Java代码与JNI本地函数的交互" class="headerlink" title="Java代码与JNI本地函数的交互"></a>Java代码与JNI本地函数的交互</h2><p>使用JNI一般遵循以下步骤：</p>
<ol>
<li>声明本地方法。在Java类中使用<code>native</code>关键字声明本地方法并加载本地函数库。</li>
<li>建立映射关系。使用<code>javah</code>命令，生成包含JNI本地函数原型的头文件，建立Java方法与C/C++本地函数间的映射。另外，在C/C++本地函数里使用<code>RegisterNatives()</code>也可直接创建映射关系，且速度较快。</li>
<li>实现C/C++本地函数。根据上面提供的头文件实现本地函数。</li>
<li>编译本地函数，生成C/C++共享库</li>
<li>Java代码通过JNI调用本地函数。本地函数可以使用虚拟机传递过来的<code>JNIEnv *</code>指针调用JNI函数，进而调用Java代码。</li>
</ol>
<p><strong>不遵循以上步骤的场景</strong>：如果仅仅只是编写C/C++应用，然后复用Java提供的库来实现某些功能，不涉及编写Java类调用C/C++函数的代码，则不需要遵循上面的步骤，而是直接在C函数里创建虚拟机并获取对应的<code>JNIEnv *</code>指针，然后通过JNI函数调用Java代码即可。</p>
<p><img src="/images/aosp10-jni-guide.drawio.svg" alt="aosp10-jni-guide.drawio"></p>
<blockquote>
<p>思考：能否基于JNI开发主要使用C/C++编写的本地应用程序？不妥，JNI函数调用的开销应该比较大，影响性能。</p>
</blockquote>
<h1 id="JNI使用示例"><a href="#JNI使用示例" class="headerlink" title="JNI使用示例"></a>JNI使用示例</h1><h2 id="Java代码调用C-C-本地函数"><a href="#Java代码调用C-C-本地函数" class="headerlink" title="Java代码调用C/C++本地函数"></a>Java代码调用C/C++本地函数</h2><ol>
<li><p>在Java类中声明本地方法并加载本地函数库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloJNI.java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloJNI</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(String str)</span></span>; <span class="comment">// 声明本地方法</span></span><br><span class="line">	<span class="keyword">static</span> &#123; System.loadLibrary(<span class="string">&quot;hellojni&quot;</span>); &#125; <span class="comment">// 加载本地函数库</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">		HelloJNI myJNI = <span class="keyword">new</span> HelloJNI();</span><br><span class="line">		myJNI.printString(<span class="string">&quot;Hello World from native&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>javah</code>命令，生成包含JNI本地函数原型的头文件，建立Java方法与C/C++本地函数间的映射</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ javac HelloJNI.java</span><br><span class="line">$ javah HelloJNI</span><br><span class="line">$ ls</span><br><span class="line">HelloJNI.class  HelloJNI.h  HelloJNI.java</span><br><span class="line">$ cat HelloJNI.h</span><br><span class="line">...</span><br><span class="line">/*</span><br><span class="line"> * Class:     HelloJNI <span class="comment"># 对应的Java类名</span></span><br><span class="line"> * Method:    printString <span class="comment"># 方法名</span></span><br><span class="line"> * Signature: (Ljava/lang/String;)V  <span class="comment"># 方法签名，括号内为入参，括号外为返回值</span></span><br><span class="line"> */</span><br><span class="line">JNIEXPORT void JNICALL Java_HelloJNI_printString</span><br><span class="line">  (JNIEnv *, jobject, jstring); <span class="comment"># 本地函数原型</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>HelloJNI.h</code>头文件中包含基于Java方法生成的本地函数原型以及注释，本地函数原型说明如下：</p>
<ul>
<li>JNIEXPORT、JNICALL：关键字，JNI需要此关键字才能正常调用函数。</li>
<li>Java_HelloJNI_printString：本地函数名，格式<code>Java_类名_方法名</code>。</li>
<li>JNIEnv *, jobject：默认参数，JNIEnv *指向JNI提供的基本函数集，可用来调用相关函数；jobject表示调用本地方法的Java本地对象，如果调用静态方法则为jclass，表示Java本地类。</li>
</ul>
</li>
<li><p>实现JNI本地函数：编写<code>hellojni.c</code>文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HelloJNI.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_HelloJNI_printString</span><span class="params">(JNIEnv *env, jobject obj, jstring <span class="built_in">string</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// jni.h文件里声明了GetStringUTFChars()函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = (*env)-&gt;GetStringUTFChars(env, <span class="built_in">string</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生成C共享库。以Windows平台为例，生成<code>hellojni.dll</code>文件</p>
<p>在<code>Visual C++ 2015 x86 x64 Cross Build Tools Command Prompt</code>编译代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># C:\Program Files\Java\jdk1.8.0_251 为JDK Home目录</span></span><br><span class="line">$ cl -I<span class="string">&quot;C:\Program Files\Java\jdk1.8.0_251\include&quot;</span> -I<span class="string">&quot;C:\Program Files\Java\jdk1.8.0_251\include\win32&quot;</span> -LD hellojni.c -Fehellojni.dll</span><br></pre></td></tr></table></figure></li>
<li><p>Java代码通过JNI调用本地函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java HelloJNI</span><br><span class="line">Hello World from native!</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="C-C-本地函数调用Java代码"><a href="#C-C-本地函数调用Java代码" class="headerlink" title="C/C++本地函数调用Java代码"></a>C/C++本地函数调用Java代码</h2><p>C/C++函数调用Java代码的用法有：获取Java类的class，创建Java类的对象实例，调用类的静态成员变量和静态方法，调用对象的成员变量和方法。相关JNI接口都声明在<code>&lt;JDK_HOME&gt;/include/jni.h</code>中。</p>
<p>相关部分接口(C++)，通过<code>JNIEnv *</code>调用如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询并加载类</span></span><br><span class="line"><span class="function">jclass <span class="title">FindClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取类的静态方法</span></span></span><br><span class="line"><span class="function">jmethodID <span class="title">GetStaticMethodID</span><span class="params">(jclass clazz, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *sig)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 调用类的静态方法 XXX表示Object、Boolean等方法返回值类型</span></span></span><br><span class="line"><span class="function">jXXX <span class="title">CallStaticXXXMethod</span><span class="params">(jclass clazz, jmethodID methodID, ...)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 查找方法. 构造方法： name=&quot;&lt;init&gt;&quot;, sig为签名如&quot;(I)V&quot;</span></span></span><br><span class="line"><span class="function">jmethodID <span class="title">GetMethodID</span><span class="params">(jclass clazz, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *sig)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 创建Java对象实例</span></span></span><br><span class="line"><span class="function">jobject <span class="title">NewObject</span><span class="params">(jclass clazz, jmethodID methodID, ...)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 调用普通对象方法</span></span></span><br><span class="line"><span class="function">jxxx <span class="title">CallXxxMethod</span><span class="params">(jobject obj, jmethodID methodID, ...)</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述接口，在C里需要在入参里添加env(JNIEnv *)。</p>
</blockquote>
<p><strong>C函数主动调用Java代码注意事项</strong></p>
<p>调用JNI方法的前提是持有<code>JNIEnv *</code>指针，该指针一般通过Java调用本地方法传给C/C++函数。但如果C/C++函数主动调用Java的代码时没有持有该指针，或者此时Java虚拟机没有启动，则C/C++如何调用Java代码呢？答案是在C函数里主动生成虚拟机，获取与该虚拟机对应的<code>JNIEnv *</code>指针，然后就可以调用Java代码了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成虚拟机的接口</span></span><br><span class="line">JNI_CreateJavaVM(JavaVM **pvm, <span class="keyword">void</span> **penv, <span class="keyword">void</span> *args);</span><br></pre></td></tr></table></figure>

<p>注意：通过主动生成虚拟机获取<code>JNIEnv *</code>指针，然后调用Java代码时，无需创建Java方法与本地C/C++函数间的映射表这一步骤。</p>
<h1 id="使用Android-NDK开发"><a href="#使用Android-NDK开发" class="headerlink" title="使用Android NDK开发"></a>使用Android NDK开发</h1><p>在开发Android里的JNI相关的功能，可使用Android Studio配套的NDK工具包，一键编译，方便快速开发。</p>
<p>NDK使用的官方介绍：<a target="_blank" rel="noopener" href="https://developer.android.google.cn/ndk">Android NDK</a></p>
<p>NDK使用示例见官方CodeLab: <a target="_blank" rel="noopener" href="https://developer.android.google.cn/codelabs/android-studio-cmake#0">Create Hello-CMake with Android Studio</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>金泰廷等著《Android框架解密》，人民邮电出版社，2012。该书分析的代码较老，但框架机制基本不变，非常好的书籍。</li>
<li>源码查看网站：<a target="_blank" rel="noopener" href="http://aospxref.com/%E3%80%82%E5%9F%BA%E4%BA%8EOpenGrok%E7%9A%84%E6%BA%90%E7%A0%81%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E7%BD%91%E7%AB%99%EF%BC%8C%E9%80%9F%E5%BA%A6%E5%BE%88%E5%BF%AB%EF%BC%8C%E4%B8%BB%E8%A6%81%E7%94%A8%E6%9D%A5%E6%9F%A5%E7%9C%8BC/C++%E4%BB%A3%E7%A0%81%EF%BC%8CJava%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%9C%AC%E5%9C%B0%E6%9F%A5%E7%9C%8B%E3%80%82">http://aospxref.com/。基于OpenGrok的源码查看服务网站，速度很快，主要用来查看C/C++代码，Java代码可下载到本地查看。</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.android.google.cn/codelabs/android-studio-cmake#0">Create Hello-CMake with Android Studio</a>:NDK开发示例</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangliangnbu.github.io/2021/12/07/android-update-ui-in-sub-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="章亮">
      <meta itemprop="description" content="Developer For Android">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒的码流">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/07/android-update-ui-in-sub-thread/" class="post-title-link" itemprop="url">探讨-如何在子线程直接刷新主线程的UI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-07 15:18:11" itemprop="dateCreated datePublished" datetime="2021-12-07T15:18:11+08:00">2021-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-09 09:01:54" itemprop="dateModified" datetime="2021-12-09T09:01:54+08:00">2021-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Android开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h1><p>之前被问到一个问题：如何在子线程中不通过Handler而直接更新主线程的UI，比如在主线程创建的TextView，如何在子线程直接调用<code>setText()</code>方法更新文本？实例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TextView tv1;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tv1 = findViewById(R.id.tv_hw);</span><br><span class="line">        tv1.setOnClickListener(v -&gt; <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            tv1.setText(<span class="string">&quot;子线程刷新UI&quot;</span>);</span><br><span class="line">        &#125;).start());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接运行上述代码会导致程序崩溃，调用栈如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">E/AndroidRuntime: FATAL EXCEPTION: Thread-2</span><br><span class="line">    Process: com.xxx.viewsettextdemo, PID: 4387</span><br><span class="line">    android.view.ViewRootImpl<span class="variable">$CalledFromWrongThreadException</span>: Only the original thread that created a view hierarchy can touch its views.</span><br><span class="line">        at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:8191)</span><br><span class="line">        at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1420)</span><br><span class="line">        at android.view.View.requestLayout(View.java:24469)</span><br><span class="line">        at android.view.View.requestLayout(View.java:24469)</span><br><span class="line">        at android.view.View.requestLayout(View.java:24469)</span><br><span class="line">        at android.view.View.requestLayout(View.java:24469)</span><br><span class="line">        at android.view.View.requestLayout(View.java:24469)</span><br><span class="line">        at android.view.View.requestLayout(View.java:24469)</span><br><span class="line">        at androidx.constraintlayout.widget.ConstraintLayout.requestLayout(ConstraintLayout.java:3146)</span><br><span class="line">        at android.view.View.requestLayout(View.java:24469)</span><br><span class="line">        at android.widget.TextView.checkForRelayout(TextView.java:9681)</span><br><span class="line">        at android.widget.TextView.setText(TextView.java:6269)</span><br><span class="line">        at android.widget.TextView.setText(TextView.java:6097)</span><br><span class="line">        at android.widget.TextView.setText(TextView.java:6049)</span><br><span class="line">        at com.xxx.viewsettextdemo.MainActivity.lambda$onCreate$0<span class="variable">$MainActivity</span>(MainActivity.java:22)</span><br><span class="line">        at com.xxx.viewsettextdemo.-$$Lambda$MainActivity<span class="variable">$_uRJsNnQ0</span>-zyKYjBJhwoyKb6E_I.run(Unknown Source:2)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:919)</span><br></pre></td></tr></table></figure>

<p>有什么方法，保证程序不崩溃且能够更新UI？</p>
<h1 id="探讨"><a href="#探讨" class="headerlink" title="探讨"></a>探讨</h1><p>问题出现在调用<code>ViewRootImpl.checkThread()</code>方法时，抛出错误：”CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常消息是说，只有创建View所属视图树的线程才能更新该View，判断依据是ViewRootImpl的mThread成员与当前线程不一致。mThread只在ViewRootImpl构造方法里进行赋值，而ViewRootImpl是在WindowManager(实际为WindowManagerGlobal)的addView方法里进行实例化的，且不能被应用开发者直接实例化。在不更改系统代码的情况下，可以进行如下尝试：</p>
<h3 id="方案-1"><a href="#方案-1" class="headerlink" title="方案 1"></a>方案 1</h3><p>在主线程中移除目标View，然后在子线程通过WindowManager.addView()添加该view。addView()会创建新的ViewRootImpl实例，并将目标View添加新的ViewRootImpl对应的视图树中。这种方法仅仅解决了在子线程中更新主线程中创建的View问题，但在UI层面则表现为子线程创建了一个新的窗口，此时目标View已经离开了主线程创建的窗口而位于新窗口中，更新的也仅仅是新窗口中的UI，并不能算是子线程更新了主线程的UI，此时主线程UI会缺失目标View。</p>
<p>具体代码如下，在上述代码中，添加一个按钮，点击按钮时触发创建子线程操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">btn.setOnClickListener(v -&gt; <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 主线程中的View只能在主线程中移除</span></span><br><span class="line">    MainActivity.<span class="keyword">this</span>.runOnUiThread(() -&gt; &#123;</span><br><span class="line">        ViewGroup parent = (ViewGroup) tv1.getParent();</span><br><span class="line">        parent.removeView(tv1);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// addView()时会调用Handler发消息到该线程，需要Looper</span></span><br><span class="line">    Looper.prepare();</span><br><span class="line">    WindowManager wm = getWindowManager();</span><br><span class="line">    WindowManager.LayoutParams lp = <span class="keyword">new</span> WindowManager.LayoutParams(</span><br><span class="line">        WindowManager.LayoutParams.MATCH_PARENT,</span><br><span class="line">        WindowManager.LayoutParams.WRAP_CONTENT,</span><br><span class="line">        WindowManager.LayoutParams.TYPE_APPLICATION,</span><br><span class="line">        WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</span><br><span class="line">        | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL,</span><br><span class="line">        PixelFormat.TRANSLUCENT);</span><br><span class="line">    wm.addView(tv1, lp);</span><br><span class="line">    tv1.setTextColor(Color.BLACK);</span><br><span class="line">    tv1.setText(<span class="string">&quot;我是在子线程中的的更新的UI&quot;</span>);</span><br><span class="line">    Looper.loop();</span><br><span class="line">&#125;).start());</span><br></pre></td></tr></table></figure>

<p>具体效果如下</p>
<p>进入应用，依次为TextView和Button：</p>
<p><img src="/images/android-update-ui-2.png"></p>
<p>点击“子线程更新UI”的Button，TextView出现在新的窗口中且文本被更新：</p>
<p><img src="/images/android-update-ui-1.png"></p>
<p>上述方案与直接在子线程中创建View实例是一样的，唯一的区别是创建实例的地方不一样。该方案仅仅解决了如何在子线程中更新主线程创建的View实例信息这个问题而已，并没有完全解决文章开始提到的问题。</p>
<p>不修改系统代码，而仅仅使用目前的SDK提供的API，我认为很难解决该问题，因为无法绕过<code>ViewRootImpl.checkThread()</code>方法，也许有其他的Trick，待以后跟进。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="章亮"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">章亮</p>
  <div class="site-description" itemprop="description">Developer For Android</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangliangnbu" title="GitHub → https://github.com/zhangliangnbu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhangliangnbu@qq.com" title="E-Mail → mailto:zhangliangnbu@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">章亮</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">249k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:47</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
