<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangliangnbu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="当我们调用TextView.setTextColor()之后，UI就会更新，这一过程是怎样的？本文通过较完整的视图绘制流程分析Android的图形系统。  这里的绘制流程是指UI从数据更改触发到最终更新的流程。  代码基于Android 10。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android图形系统概览">
<meta property="og:url" content="https://zhangliangnbu.github.io/2021/12/23/android-ui-system-guide/index.html">
<meta property="og:site_name" content="永恒的码流">
<meta property="og:description" content="当我们调用TextView.setTextColor()之后，UI就会更新，这一过程是怎样的？本文通过较完整的视图绘制流程分析Android的图形系统。  这里的绘制流程是指UI从数据更改触发到最终更新的流程。  代码基于Android 10。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangliangnbu.github.io/images/wms-client-server-ui.svg">
<meta property="og:image" content="https://zhangliangnbu.github.io/images/android-draw-total-flow.svg">
<meta property="og:image" content="https://zhangliangnbu.github.io/images/android-set-text-color-sq.svg">
<meta property="og:image" content="https://zhangliangnbu.github.io/images/android-surface-create-class-uml.svg">
<meta property="og:image" content="https://zhangliangnbu.github.io/images/android-surface-create-sq-flow-16403397442681.svg">
<meta property="og:image" content="https://zhangliangnbu.github.io/images/android-surface-control-create-sq-flow.svg">
<meta property="og:image" content="https://zhangliangnbu.github.io/images/android-surface-self-create-sq-flow.svg">
<meta property="article:published_time" content="2021-12-23T09:01:27.000Z">
<meta property="article:modified_time" content="2022-01-07T07:19:34.872Z">
<meta property="article:author" content="章亮">
<meta property="article:tag" content="android">
<meta property="article:tag" content="android系统开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangliangnbu.github.io/images/wms-client-server-ui.svg">

<link rel="canonical" href="https://zhangliangnbu.github.io/2021/12/23/android-ui-system-guide/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Android图形系统概览 | 永恒的码流</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">永恒的码流</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">万物皆流，无物常驻</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangliangnbu.github.io/2021/12/23/android-ui-system-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="章亮">
      <meta itemprop="description" content="Developer For Android">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恒的码流">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android图形系统概览
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-23 17:01:27" itemprop="dateCreated datePublished" datetime="2021-12-23T17:01:27+08:00">2021-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-07 15:19:34" itemprop="dateModified" datetime="2022-01-07T15:19:34+08:00">2022-01-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Android系统开发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>当我们调用<code>TextView.setTextColor()</code>之后，UI就会更新，这一过程是怎样的？本文通过较完整的视图绘制流程分析Android的图形系统。</p>
<blockquote>
<p>这里的绘制流程是指UI从数据更改触发到最终更新的流程。</p>
</blockquote>
<p>代码基于Android 10。</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>对于Android图形系统，可以这样理解：App中我们见到状态栏、Activity界面、弹窗等都是一个个窗口，对应App端的Window和服务端的WindowState；每个窗口包含多个控件，对应View和ViewGroup；每个窗口独占单独的画布，对应Surface（持有Canvas）；多个画布内容通过SurfaceFlinger合成一帧画面，最后通过显示设备输出。</p>
<blockquote>
<p>说得比较粗糙，实际情况较复杂，待以后优化 <strong>TODO</strong></p>
</blockquote>
<p>简单的对应关系如图：</p>
<p><img src="/images/wms-client-server-ui.svg" alt="wms-client-server-ui"></p>
<p>Window和WindowState都间接持有Surface的引用，WindowState持有与SurfaceFlinger的连接Session。可通俗理解为，多个View控件构成一个Surface内容，多个Surface内容通过SurfaceFlinger合成为一帧最终输出的图像。</p>
<p>下面以具体代码来分析Android图形系统，分析<code>TextView.setTextColor()</code>从调用到UI更新的调用链流程，可分为：</p>
<ul>
<li>准备阶段：计算脏区位置和宽高（Dirty Rect，就是待更新区域）、测量、布局，之后调用<code>ViewRootImpl.performDraw()</code>尝试硬件绘制，不能或不成功则进行软件绘制。</li>
<li>绘制操作：区分软件绘制和硬件绘制，绘制数据有所差别，但最终都是将绘制数据填充到GraphicBuffer，通知SurfaceFlinger进行合成。</li>
<li>合成展示：SurfaceFlinger利用硬件(OpenGL 和 HardWare Composer)将 GraphicBuffer 数据合成并交给Display Buffer去显示。</li>
</ul>
<p>整个流程如下：</p>
<p><img src="/images/android-draw-total-flow.svg" alt="android-draw-total-flow"></p>
<blockquote>
<p>这幅图参考<a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/11/09/Android-Surface%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">Android-Surface原理解析</a>，图例比较清晰全面，我直接拿过来并重新绘制了全图。</p>
</blockquote>
<h1 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h1><p>准备阶段时序图如下：</p>
<p><img src="/images/android-set-text-color-sq.svg" alt="android-set-text-color-sq"></p>
<blockquote>
<p>略繁琐，逻辑不够清晰，待以后更新 <strong>TODO</strong></p>
</blockquote>
<p>大致流程为：首先计算脏区尺寸和位置，之后调用<code>ViewRootImpl.performTraversals()</code>进行测量、布局和绘制操作。</p>
<h2 id="计算脏区在屏幕中的位置和宽高"><a href="#计算脏区在屏幕中的位置和宽高" class="headerlink" title="计算脏区在屏幕中的位置和宽高"></a>计算脏区在屏幕中的位置和宽高</h2><p>计算时会调用<code>ViewGroup.invalidateChild()</code>遍历当前View的所有的<code>ViewParent</code>，直到<code>ViewRootImpl</code>为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewGroup.java</span></span><br><span class="line"><span class="comment">// 这个child是实例中待更新的TextView</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invalidateChild</span><span class="params">(View child, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line">    ViewParent parent = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] location = attachInfo.mInvalidateChildLocation;</span><br><span class="line">    location[CHILD_LEFT_INDEX] = child.mLeft;</span><br><span class="line">    location[CHILD_TOP_INDEX] = child.mTop;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的ViewParentt以计算脏区. 首先进入ViewGroup，最后进入ViewRootImpl</span></span><br><span class="line">        parent = parent.invalidateChildInParent(location, dirty);</span><br><span class="line">    &#125; <span class="keyword">while</span> (parent != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测量视图树中所有View的宽高"><a href="#测量视图树中所有View的宽高" class="headerlink" title="测量视图树中所有View的宽高"></a>测量视图树中所有View的宽高</h2><p>在<code>ViewRootImpl.performTraversals()</code>中会依次调用<code>performMeasure()</code>、<code>performLayout()</code>、<code>performDraw()</code>三个主要方法。<code>performMeasure()</code>即测量。测量的工作是确定View的宽高，测量的主要规则通过父布局的MeasureSpec确定子View的宽高。</p>
<p>详细流程：首先确定根View的MeasureSpec；然后通过父布局的MeasureSpec确定子View的MeasureSpec；最后在onMeasure方法中根据这个MeasureSpec来确定View的测量宽高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的mView指根View, 一般为DecorView</span></span><br><span class="line">	mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ViewGroup控件调用 ViewGroup.onMeasure(), 非ViewGroup调用View.onMeasure()</span></span><br><span class="line">    onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>在<code>ViewRootImpl.performTraversals()</code>中<code>performLayout()</code>执行布局。<strong>TODO</strong></p>
<p>之后，在<code>ViewRootImpl.performDraw()</code>中首先尝试硬件绘制，不能或不成功则软件绘制。软件绘制会调用<code>ViewRootImpl.drawSoftware</code>，其中会通过<code>Surface</code>生成<code>Canvas</code>以传递给视图树使用。</p>
<h1 id="绘制阶段"><a href="#绘制阶段" class="headerlink" title="绘制阶段"></a>绘制阶段</h1><h2 id="Surface的创建"><a href="#Surface的创建" class="headerlink" title="Surface的创建"></a>Surface的创建</h2><p>绘制流程中涉及到Surface，有必要先描述Surface相关对象的创建。相关对象有：SurfaceSession、SurfaceControl和Surface。这三个对象的Java层实例都持有其Native层的指针，实际绘制工作最终都由Native层完成。</p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>SurfaceSession是App端与SurfaceFlinger的连接，可用于创建的SurfaceControl，后者用于创建Surface。</p>
<blockquote>
<p>这里说的创建对象，包括Java层和Native层</p>
</blockquote>
<p>在 Java 层 ViewRootImpl 实例中持有一个 Surface 对象，该 Surface 对象中的 mNativeObject 属性指向 native 层中创建的 Surface 对象，native 层的 Surface 对应 SurfaceFlinger 中的 Layer 对象，它持有 Layer 中对应的 BufferQueueProducer 生产者指针，在 Surface 上绘制的内容最终会交由 SurfaceFlinger 来合成渲染送到显示器显示。</p>
<p>创建过程中，涉及到的Java层和Native层的类：</p>
<p><img src="/images/android-surface-create-class-uml.svg" alt="android-surface-create-class-uml"></p>
<h3 id="SurfaceSession"><a href="#SurfaceSession" class="headerlink" title="SurfaceSession"></a><strong>SurfaceSession</strong></h3><p>代表Surface与SurfaceFlinger 的连接，通过该连接可以创建多个Surface实例；持有客户端SurfaceComposerClient的指针，连接的实现由其实现，可用于创建SurfaceControl。</p>
<p>SurfaceSession对象是在Window添加流程中创建的，在<code>WMS.addWindow() </code>方法中创建 WindowState，它会调用<code>WindowState.attach()</code>方法，该方法内调用<code>Session.windowAddedLocked()</code>，在这里创建Java端的SurfaceSession对象。SurfaceSession构造方法会通过JNI创建一个 Native端的SurfaceComposerClient 对象，后者又创建了一个 实现了ISurfaceComposerClient接口的Client 对象，通过此对象与SurfaceFlinge通信。</p>
<p>创建的时序图：</p>
<p><img src="/images/android-surface-create-sq-flow-16403397442681.svg" alt="android-surface-create-sq-flow"></p>
<p>相关代码：由于涉及C++代码，稍微贴下较详细的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Session.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">windowAddedLocked</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">    mSurfaceSession = <span class="keyword">new</span> <span class="built_in">SurfaceSession</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceSession.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mNativeClient; <span class="comment">// SurfaceComposerClient*</span></span><br><span class="line"><span class="comment">// 创建与Surface Flinger的连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SurfaceSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mNativeClient = <span class="built_in">nativeCreate</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_SurfaceSession.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    SurfaceComposerClient* client = <span class="keyword">new</span> <span class="built_in">SurfaceComposerClient</span>();</span><br><span class="line">    client-&gt;<span class="built_in">incStrong</span>((<span class="keyword">void</span>*)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用incStrong函数时，如果SurfaceComposerClient是第一次被引用则会调用onFirstRef()函数</span></span><br><span class="line"><span class="comment">// frameworks/native/libs/gui/SurfaceComposerClient.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceComposerClient::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从服务端(surface flinger)获取服务</span></span><br><span class="line">    <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sf</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line">    <span class="comment">// 通过服务创建连接</span></span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; conn = sf-&gt;<span class="built_in">createConnection</span>();</span><br><span class="line">    mClient = conn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function">sp&lt;ISurfaceComposerClient&gt; <span class="title">SurfaceFlinger::createConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initClient方法只是调用initCheck检查了一下</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">initClient</span>(<span class="keyword">new</span> <span class="built_in">Client</span>(<span class="keyword">this</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SurfaceControl"><a href="#SurfaceControl" class="headerlink" title="SurfaceControl"></a><strong>SurfaceControl</strong></h3><p>用于Surface的创建等管理。</p>
<p>客户端ViewRootImpl中持有一个SurfaceControl，但开始是无内容无效的，没有持有Native层对象的指针。<code>ViewRootImpl.performTraversals()</code>中会调用<code>ViewRootImpl.relayoutWindow()</code>方法，之后会通过Session将此SurfaceControl传给WMS，WMS创建WindowSurfaceController对象，该对象构造器内部创建并持有新的SurfaceControl实例，它通过<code>nativeCreate()</code>方法创建底层实例即客户端的SurfaceControl以及SurfaceFlinger端的Layer，并持有底层SurfaceControl的指针。</p>
<p>另外：创建SurfaceControl流程中会创建surface flinger端的layer对象：BufferQueueLayer，并创建它的两个重要成员：BufferQueueProducer 和 BufferQueueConsumer的包装类对象。SurfaceControl和Surface持有Layer中对应的BufferQueueProducer指针，只负责生产数据流。</p>
<p>创建的时序图如下：</p>
<p><img src="/images/android-surface-control-create-sq-flow.svg" alt="android-surface-control-create-sq-flow"></p>
<p>关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要进行布局操作时</span></span><br><span class="line">    relayoutWindow(params, viewVisibility, insetsPending)</span><br><span class="line">    <span class="comment">// measure, layout, draw</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createSurfaceControl</span><span class="params">(SurfaceControl outSurfaceControl...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最终通过SurfaceSession创建SurfaceControl, 并创建Native层对象</span></span><br><span class="line">    WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_SurfaceControl.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(jobject sessionObj, ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sessionObj 即SurfaceSession，在Window添加流程中已创建</span></span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client = android_view_SurfaceSession_getClient(...sessionObj);;</span><br><span class="line">    <span class="comment">// 创建SurfaceControl, 最终通过Native层的连接ISurfaceComposerClient创建</span></span><br><span class="line">    client-&gt;createSurfaceChecked(..., &amp;surface, ..., parent, ...));</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/libs/gui/SurfaceComposerClient.cpp</span></span><br><span class="line">status_t SurfaceComposerClient::createSurfaceChecked() &#123;</span><br><span class="line">    <span class="comment">// 这里的mClient是指接口ISurfaceComposerClient, 详情见上面SurfaceSession创建流程</span></span><br><span class="line">    status_t err = mClient-&gt;createSurface(..., &amp;gbp);</span><br><span class="line">    *outSurface = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp, <span class="keyword">true</span> <span class="comment">/* owned */</span>);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/Client.cpp</span></span><br><span class="line">status_t Client::createSurface(...sp&lt;IGraphicBufferProducer&gt;* gbp) &#123;</span><br><span class="line">    <span class="comment">// 通过SurfaceFlinger创建Layer</span></span><br><span class="line">    <span class="keyword">return</span> mFlinger-&gt;createLayer(...handle, gbp, parentHandle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h3><p>在<code>ViewRootImpl.relayoutWindow()</code>中，首先调用<code>mWindowSession.relayout()</code>生成并初始化SurfaceControl，接着在Native 层中，通过SurfaceControl创建Surface，并将地址指针赋值给Java层Surface的mNativeObject成员。</p>
<p><img src="/images/android-surface-self-create-sq-flow.svg" alt="android-surface-self-create-sq-flow"></p>
<p>关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, ...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化SurfaceControl</span></span><br><span class="line">    mWindowSession.relayout(mWindow,...,mSurfaceControl,...);</span><br><span class="line">    <span class="comment">// 按理说Binder通信会copy数据，但最最终是否会修改此处的mSurfaceControl？</span></span><br><span class="line">    <span class="comment">// 如果此处不修改，又在何处修改呢，找不出明确修改mSurfaceControl的地方，但感觉应该修改了</span></span><br><span class="line">    mSurface.copyFrom(mSurfaceControl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/jni/android_view_Surface.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeGetFromSurfaceControl</span><span class="params">(...jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line">    Surface* self(reinterpret_cast&lt;Surface *&gt;(nativeObject));</span><br><span class="line">    <span class="function">sp&lt;SurfaceControl&gt; <span class="title">ctrl</span><span class="params">(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj)</span>)</span>;</span><br><span class="line">    <span class="comment">// 首次需要创建</span></span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(ctrl-&gt;getSurface()</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/native/libs/gui/SurfaceControl.cpp</span></span><br><span class="line">sp&lt;Surface&gt; SurfaceControl::generateSurfaceLocked() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// gbp在SurfaceControl时已创建</span></span><br><span class="line">    mSurfaceData = <span class="keyword">new</span> Surface(mGraphicBufferProducer, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="绘制操作"><a href="#绘制操作" class="headerlink" title="绘制操作"></a>绘制操作</h2><p>绘制即在Android APP 进程中将 UI 绘制到一个图形缓冲区 GraphicBuffer 中的过程。绘制操作包括两种实现方式：软件绘制和硬件绘制（也叫硬件加速，下面统一称为硬件绘制）。硬件绘制会使用 GPU将图形 加速渲染到 GraphicBuffer 。</p>
<p>绘制入口为<code>ViewRootImpl.draw()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">        mAttachInfo.mThreadedRenderer.draw(mView ...); <span class="comment">// 硬件绘制</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        drawSoftware(surface, ...) <span class="comment">// 软件绘制</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> useAsyncReport;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><strong>软件绘制</strong></p>
<p>当 App 更新部分 UI 时，CPU 会遍历 View Tree 计算出需要重绘的脏区，接着在 View 层次结构中绘制所有跟脏区相交的区域，之后将绘制的内容写进一个 Bitmap 位图，这个 Bitmap 的像素内容会填充到 Surface 的缓存区里。软件绘制使用 Skia 库。</p>
<p>缺点：可能重绘无需更新的视图；主线程绘制容易造成卡顿情况。</p>
<p><strong>硬件绘制</strong></p>
<p>当 App 更新部分 UI 时，CPU 会计算出脏区，但是不会立即执行绘制命令，而是将 drawXXX 函数作为绘制指令(DrawOp)记录在一个列表(DisplayList)中，然后交给单独的 Render 线程使用 GPU 进行硬件加速渲染。</p>
<p>硬件绘制使用 OpenGL 在 GPU 上完成，OpenGL 是跨平台的图形 API，为 2D/3D 图形处理硬件制定了标准的软件接口。Skia 已接手 OpenGL，实现间接统一调用。</p>
<p>优点：</p>
<ol>
<li>无需重绘所有相交区域。只需要针对需要更新的 View 对象的脏区进行记录或更新，无需更新的 View 对象则能重用先前 DisplayList 中记录的指令。</li>
<li>单独线程绘制可缓解卡顿情况。硬件加速是在单独的 Render 线程中完成绘制的，分担了主线程的压力，提高了响应速度。</li>
</ol>
<p>缺点：兼容性（部分绘制函数不支持加速），内存消耗，电量消耗（GPU耗电）等。</p>
<blockquote>
<p> 从 Android 3.0(API 11)开始支持硬件加速，Android 4.0(API 14)默认开启硬件加速。</p>
</blockquote>
<p>配置硬件绘制：</p>
<ul>
<li>Application: 在 Manifest 文件的 application 标签添加 <code>android:hardwareAccelerated=&quot;boolean&quot;</code></li>
<li>Activity: 在 Manifest 文件的 activity 标签添加 <code>android:hardwareAccelerated=&quot;boolean&quot;</code></li>
<li>Window: <code>getWindow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED)</code></li>
<li>View: <code>setLayerType(View.LAYER_TYPE_HARDWARE/*View.LAYER_TYPE_SOFTWARE*/, mPaint)</code></li>
</ul>
<h3 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h3><p>软件绘制的入口为<code>ViewRootImpl.drawSoftware()</code>，可以简单分为三个步骤：</p>
<ol>
<li><code>Surface.lockCanvas </code>方法通过 <code>BufferQueueProducer.dequeueBuffer()</code> 函数从 BufferQueue 中取出一个图形缓存区 GraphicBuffer(用来创建 Canvas 中的 Bitmap 对象) 并锁定该Surface，然后将 Surface 的地址返回给 Java 层 Surface 中的 mLockedObject属性。在这个方法中还会涉及到 Surface 的双缓冲逻辑。</li>
<li>调用 <code>View.draw()</code> 方法将内容绘制到 Canvas 对应的 Bitmap 中，其实就是往上面的图形缓存区 GraphicBuffer 填充绘制数据。</li>
<li><code>Surface.unlockCanvasAndPost()</code> 方法通过调用被锁定的 <code>surface-&gt;unlockAndPost()</code> 方法解锁 Surface 且通过 <code>queueBuffer()</code> 函数将填充了数据的图形缓存区 GraphicBuffer 存入 BufferQueue 队列中，然后通知给 SurfaceFlinger 进行合成(请求 Vsync 信号)。</li>
</ol>
<p>对于软件绘制中的 Canvas 而言其绘制目标是一个 Bitmap 对象，绘制的内容会填充到 Surface 持有的缓存区(GraphicBuffer)里。</p>
<p><strong>简单流程即：GraphicBuffer出队→写数据到Bitmap中→GraphicBuffer入队合成。</strong></p>
<blockquote>
<p>待补流程图 <strong>TODO</strong> </p>
</blockquote>
<h3 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h3><p>硬件加速可以从两个阶段来看：</p>
<ol>
<li>构建阶段：将 View 抽象成 RenderNode 节点，将每个绘制操作(drawLine等)抽象成 DrawOp，它保存了绘制数据并与 OpenGL 绘制命令对应。这个阶段会递归遍历所有 View 并通过 Canvas.drawXXX将绘制操作转化成 DrawOp 存入 DisplayList 中，根据 ViewTree 模型，这个 DisplayList 虽然命名为List，但其实更像一棵树。</li>
<li>绘制阶段：通过单独的 Render 线程，依赖 GPU 绘制上面的 DrawOp 数据。其中硬件加速的内存申请跟软件绘制一样都是借助 Layer 中的 BufferQueueProducer 生产者从 BufferQueue 中出队列一块空闲缓存区 GraphicBuffer 用来渲染数据的，之后也都会通知 SurfaceFlinger 进行合成。不一样的地方在于硬件加速相比软件绘制而言算法可能更加合理，同时采用了一个单独的 Render 线程，减轻了主线程的负担。</li>
</ol>
<h3 id="绘制中的双缓冲"><a href="#绘制中的双缓冲" class="headerlink" title="绘制中的双缓冲"></a>绘制中的双缓冲</h3><p>一般来说将双缓冲用到的两块缓冲区称为 – 前缓冲区(front buffer) 和 后缓冲区(back buffer)。显示器显示的数据来源于front buffer 前缓存区，而每一帧的数据都绘制到 back buffer 后缓存区，在 Vsync信号到来后会交互缓存区的数据(指针指向)，这时 front buffer 和 back buffer 的称呼及功能倒转。</p>
<p><strong>软件绘制中的双缓冲</strong></p>
<p><code>Surface.lock()</code>:</p>
<ol>
<li>将出队列的空闲缓存区 GraphicBuffer 赋给后缓存区 backBuffer，将正在显示的 mPostedBuffer 赋给前缓存区。</li>
<li>计算新的脏区，并确定是否需要将前缓存区拷贝到后缓存区，依此计算出后缓存区 backBuffer 的最终数据。然后将 backBuffer 与应用层的 Canvas 关联，当操作 Canvas 绘图时会将数据绘制到 backBuffer 上。</li>
<li>锁定 backBuffer 且将 backBuffer 指针赋值给 mLockedBuffer。</li>
</ol>
<p><code>Surface.unlockAndPost()</code>:</p>
<ol>
<li>将存有绘制数据的 mLockedBuffer 解锁并将其赋值给 mPostedBuffer。</li>
<li>将 mLockedBuffer 入 BufferQueue 队列，等待被合成显示，在这里便相当于交换了前后缓冲区的指针，等到下次绘制时，接着重复上面的步骤。</li>
</ol>
<p><strong>硬件绘制中的双缓冲</strong></p>
<p>硬件绘制最终会调用 CanvasContext.draw 方法来绘制，也用到双缓冲。略… <strong>TODO</strong></p>
<h1 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h1><p>待更新 <strong>TODO</strong></p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>写的太长，累(⊙o⊙)…准备阶段缺少测量和布局流程、绘制缺少时序图和关键代码，合成和显示缺少整个章节，待以后慢慢整理、补充。</p>
<p>另外说明的是，我的文章仅仅从UI更新的流程这一个角度来分析Android图形系统，依旧不全面，一些偏底层的部分涉及较少，详细情况可参考官方的文档：<a target="_blank" rel="noopener" href="https://source.android.google.cn/devices/graphics?hl=zh-cn#android-graphics-components">Android 图形概览</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://source.android.google.cn/devices/graphics?hl=zh-cn#android-graphics-components">Android 图形概览</a></li>
<li><a target="_blank" rel="noopener" href="http://aospxref.com/android-10.0.0_r47/">Android 10 源码</a></li>
<li><a target="_blank" rel="noopener" href="https://ljd1996.github.io/2020/11/09/Android-Surface%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/">三方博客：Android-Surface原理解析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/solomarge/p/14325080.html">三方博客：C++中sp和wp</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/268894227">三方博客：C++创建对象时区分圆括号( )和大括号{ }</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/android/" rel="tag"># android</a>
              <a href="/tags/android%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/" rel="tag"># android系统开发</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/12/20/android-activity-bind-ui-guide/" rel="prev" title="Activity绑定视图流程概览">
      <i class="fa fa-chevron-left"></i> Activity绑定视图流程概览
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/27/auto-navigation-system-guide/" rel="next" title="车载导航系统概览">
      车载导航系统概览 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5"><span class="nav-number">2.</span> <span class="nav-text">准备阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E8%84%8F%E5%8C%BA%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%AE%BD%E9%AB%98"><span class="nav-number">2.1.</span> <span class="nav-text">计算脏区在屏幕中的位置和宽高</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E9%87%8F%E8%A7%86%E5%9B%BE%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89View%E7%9A%84%E5%AE%BD%E9%AB%98"><span class="nav-number">2.2.</span> <span class="nav-text">测量视图树中所有View的宽高</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%83%E5%B1%80"><span class="nav-number">2.3.</span> <span class="nav-text">布局</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E9%98%B6%E6%AE%B5"><span class="nav-number">3.</span> <span class="nav-text">绘制阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Surface%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">3.1.</span> <span class="nav-text">Surface的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">3.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SurfaceSession"><span class="nav-number">3.1.2.</span> <span class="nav-text">SurfaceSession</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SurfaceControl"><span class="nav-number">3.1.3.</span> <span class="nav-text">SurfaceControl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Surface"><span class="nav-number">3.1.4.</span> <span class="nav-text">Surface</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">3.2.</span> <span class="nav-text">绘制操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="nav-number">3.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6"><span class="nav-number">3.2.2.</span> <span class="nav-text">软件绘制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F"><span class="nav-number">3.2.3.</span> <span class="nav-text">硬件加速</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E4%B8%AD%E7%9A%84%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="nav-number">3.2.4.</span> <span class="nav-text">绘制中的双缓冲</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%88%E6%88%90%E5%92%8C%E6%98%BE%E7%A4%BA"><span class="nav-number">4.</span> <span class="nav-text">合成和显示</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E5%B0%BE"><span class="nav-number">5.</span> <span class="nav-text">结尾</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="章亮"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">章亮</p>
  <div class="site-description" itemprop="description">Developer For Android</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhangliangnbu" title="GitHub → https://github.com/zhangliangnbu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhangliangnbu@qq.com" title="E-Mail → mailto:zhangliangnbu@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">章亮</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">301k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:33</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
