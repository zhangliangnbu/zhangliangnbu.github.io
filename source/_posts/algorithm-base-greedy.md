---
title: 算法-贪心
date: 2020-01-26 15:12:03
tags:
- algorithm
- cs
categories:
- 其他
---

# 介绍

基本概念：所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。

贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，**选择的贪心策略必须具备无后效性**，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。

所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。

贪心策略适用的前提是：局部最优策略能导致产生全局最优解。

实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。

贪心算法的基本思路

- 建立数学模型来描述问题。
- 把求解的问题分成若干个子问题。
- 对每一子问题求解，得到子问题的局部最优解。
- 把子问题的解局部最优解合成原来解问题的一个解。

贪心算法的实现框架

```java
// 从问题的某一初始解出发；
while （能朝给定总目标前进一步）{
   // 利用可行的决策，求出可行解的一个解元素；
}
// 由所有解元素组合成问题的一个可行解；
```

<!--more-->

# 实践

Interval Scheduling（区间调度问题）

另：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

```java
public int eraseOverlapIntervals(int[][] intervals) {
    // 贪心界定：不重叠的最多数量肯定是
    // 每个区间的结束点尽可能小，这样后面的空间就尽可能大，容纳的区间就会尽可能多
    
    if (intervals == null || intervals.length == 0) {
        return 0;
    }
    
    // 排序
    Arrays.sort(intervals, Comparator.comparingInt(o -> o[1]));

    // 确定目标区间，移除包含目标区间结束点的区间
    int[] start = intervals[0];
    int overlap = 0;
    for (int i = 1; i < intervals.length; i ++) {
        if (intervals[i][0] < start[1]) {
            overlap ++;
        } else {
            start = intervals[i];
        }
    }
    return overlap;
}
```